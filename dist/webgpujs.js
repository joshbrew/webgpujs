(()=>{var __defProp=Object.defineProperty;var __export=(target,all)=>{for(var name in all)__defProp(target,name,{get:all[name],enumerable:true})};var webgpujs_exports={};__export(webgpujs_exports,{ShaderContext:()=>ShaderContext,ShaderHelper:()=>ShaderHelper,WGSLTranspiler:()=>WGSLTranspiler,WGSLTypeSizes:()=>WGSLTypeSizes,WebGPUjs:()=>WebGPUjs,default:()=>webgpujs_default,imageToTextureFormats:()=>imageToTextureFormats,replacements:()=>replacements,textureFormats:()=>textureFormats,vertexFormats:()=>vertexFormats});var WGSLTranspiler=class _WGSLTranspiler{static builtInUniforms={resX:{type:"f32",callback:shaderContext=>{return shaderContext.canvas?shaderContext.canvas.width:window.innerWidth}},resY:{type:"f32",callback:shaderContext=>{return shaderContext.canvas?shaderContext.canvas.height:window.innerHeight}},mouseX:{type:"f32",callback:shaderContext=>{if(!shaderContext.MOUSEMOVELISTENER){let elm=shaderContext.canvas?shaderContext.canvas:window;shaderContext.MOUSEMOVELISTENER=elm.onmousemove=evt=>{shaderContext.mouseX=evt.offsetX;shaderContext.mouseY=evt.offsetY};shaderContext.mouseX=0}return shaderContext.mouseX}},mouseY:{type:"f32",callback:shaderContext=>{if(!shaderContext.MOUSEMOVELISTENER){let elm=shaderContext.canvas?shaderContext.canvas:window;shaderContext.MOUSEMOVELISTENER=elm.onmousemove=evt=>{shaderContext.mouseX=evt.offsetX;shaderContext.mouseY=evt.offsetY};shaderContext.mouseY=0}return shaderContext.mouseY}},clicked:{type:"i32",callback:shaderContext=>{if(!shaderContext.MOUSEDOWNLISTENER){let elm=shaderContext.canvas?shaderContext.canvas:window;shaderContext.MOUSEDOWNLISTENER=elm.onmousedown=evt=>{shaderContext.clicked=true};shaderContext.MOUSEUPLISTENER=elm.onmouseup=evt=>{shaderContext.clicked=false};shaderContext.clicked=false}return shaderContext.clicked}},frame:{type:"f32",callback:function(shaderContext){if(!shaderContext.frame)shaderContext.frame=0;let result=shaderContext.frame;shaderContext.frame++;return result}},utcTime:{type:"f32",callback:shaderContext=>{return Date.now()}}};static getFunctionHead=methodString=>{let startindex=methodString.indexOf("=>")+1;if(startindex<=0){startindex=methodString.indexOf("){")}if(startindex<=0){startindex=methodString.indexOf(") {")}return methodString.slice(0,methodString.indexOf("{",startindex)+1)};static splitIgnoringBrackets=str=>{const result=[];let depth=0;let currentToken="";for(let i=0;i<str.length;i++){const char=str[i];if(char===","&&depth===0){result.push(currentToken);currentToken=""}else{currentToken+=char;if(char==="("||char==="["||char==="{"){depth++}else if(char===")"||char==="]"||char==="}"){depth--}}}if(currentToken){result.push(currentToken)}return result};static tokenize(funcStr){let head=this.getFunctionHead(funcStr);let paramString=head.substring(head.indexOf("(")+1,head.lastIndexOf(")"));let params=this.splitIgnoringBrackets(paramString).map(param=>({token:param,isInput:true}));const assignmentTokens=(funcStr.match(/(const|let|var)\s+(\w+)\s*=\s*([^;]+)/g)||[]).map(token=>({token,isInput:false}));const builtInUniformsKeys=Object.keys(this.builtInUniforms).join("|");const builtInUniformsPattern=new RegExp(`(?<![a-zA-Z0-9_])(${builtInUniformsKeys})(?![a-zA-Z0-9_])`,"g");const builtInUniformsTokens=(funcStr.match(builtInUniformsPattern)||[]).map(token=>({token,isInput:false}));let functionBody=funcStr.substring(funcStr.indexOf("{")+1,funcStr.lastIndexOf("}"));const textureCallTokens=(functionBody.match(/texture.*\w+\(([^)]+)\)/g)||[]).flatMap(call=>{let args=call.substring(call.indexOf("(")+1,call.lastIndexOf(")"));return this.splitIgnoringBrackets(args).map(arg=>{arg=arg.trim();if(!isNaN(arg)||/^.*(vec|mat).*\(/.test(arg)){return null}return{token:arg,isInput:false}}).filter(arg=>arg!==null)});params=params.concat(assignmentTokens);params=params.concat(builtInUniformsTokens);params=params.concat(textureCallTokens);return params}static excludedNames={"position":true,"pixel":true};static parse=(fstr,tokens,shaderType="compute",vertexBufferOptions)=>{const ast=[];const returnMatches=fstr.match(/^(?![ \t]*\/\/).*\breturn .*;/gm);let returnedVars=returnMatches?returnMatches.map(match=>match.replace(/^[ \t]*return /,"").replace(";","")):void 0;returnedVars=this.flattenStrings(returnedVars);if(typeof vertexBufferOptions?.[0]==="object")vertexBufferOptions.forEach(opt=>{const keys=Object.keys(opt).filter(n=>{if(n!=="stepMode"&&n!=="__COUNT")return true});keys.forEach(k=>{if(!(k in this.excludedNames)){this.excludedNames[k]=true}})});const functionBody=fstr.substring(fstr.indexOf("{"));let checked={};const exnKeys=Object.keys(this.excludedNames);const biuKeys=Object.keys(this.builtInUniforms);tokens.forEach(({token,isInput},i)=>{if(checked[token])return;checked[token]=true;let isReturned=returnedVars?.find(v=>{if(token.includes(v)){if(shaderType!=="compute"&&exnKeys.find(t=>token.includes(t))||biuKeys.find(t=>token.includes(t))){tokens[i].isInput=false}else return true}});let variableName=token.split("=")[0].trim();if(variableName.includes(" ")){let spl=variableName.split(" ");variableName=spl[1]?spl[1]:spl[0]}let isModified=new RegExp(`(?<!\\blet\\s+|\\bvar\\s+|\\bconst\\s+)\\b${variableName}\\b(?:\\[[^\\]]*\\])?\\s*=`).test(functionBody);if(token.includes("=")){const variableMatch=token.match(/(const|let|var)?\s*(\w+)\s*=\s*(.+)/);if(variableMatch&&(variableMatch[3].startsWith("new")||variableMatch[3].startsWith("["))){let length;if(variableMatch[3].startsWith("new Array(")){const arrayLengthMatch=variableMatch[3].match(/new Array\((\d+)\)/);length=arrayLengthMatch?parseInt(arrayLengthMatch[1]):void 0}else if(variableMatch[3].startsWith("new")){const typedArrayLengthMatch=variableMatch[3].match(/new \w+Array\(\[([^\]]+)\]\)/);length=typedArrayLengthMatch?typedArrayLengthMatch[1].split(",").length:void 0}else{const directArrayLengthMatch=variableMatch[3].match(/\[([^\]]+)\]/);length=directArrayLengthMatch?directArrayLengthMatch[1].split(",").length:void 0}ast.push({type:"array",name:variableMatch[2],value:variableMatch[3],isInput,length,isReturned:returnedVars?returnedVars?.includes(variableMatch[2]):isInput?true:false,isModified})}else if(token.startsWith("vec")||token.startsWith("mat")){const typeMatch=token.match(/(vec\d+|mat\d+x\d+)(f|h|i|u|<[^>]+>)?\(([^)]+)\)/);if(typeMatch){let type=typeMatch[1];let format=typeMatch[2];switch(format){case"f":format="<f32>";break;case"h":format="<f16>";break;case"i":format="<i32>";break;case"u":format="<u32>";break;default:format=format||"<f32>"}ast.push({type,name:token.split("=")[0].trim(),value:format,isInput,isReturned:returnedVars?returnedVars.includes(token.split("=")[0].trim()):isInput?true:false,isModified})}}else{if(variableMatch[3].includes("array")){ast.push({type:"array",name:variableMatch[2],value:variableMatch[3],isInput,isReturned:returnedVars?returnedVars?.includes(variableMatch[2]):isInput?true:false,isModified})}else{ast.push({type:"variable",name:variableMatch[2],value:variableMatch[3],isUniform:true,isInput,isReturned:returnedVars?returnedVars?.includes(variableMatch[2]):isInput?true:false,isModified})}}}else{ast.push({type:"variable",name:token,value:"unknown",isInput,isReturned,isModified})}});return ast};static inferTypeFromValue(value,funcStr,ast,defaultValue="f32"){value=value.trim();if(value==="true"||value==="false")return"bool";else if(value.startsWith('"')||value.startsWith("'")||value.startsWith("`"))return value.substring(1,value.length-1);else if(value.startsWith("vec")){const VecMatch=value.match(/vec(\d+)(f|h|i|u|<[^>]+>)?/);if(VecMatch){const vecSize=VecMatch[1];let type=VecMatch[2];if(!type){type=value.includes(".")?"<f32>":"<i32>"}else if(type.length===1){switch(type){case"f":type="<f32>";break;case"h":type="<f16>";break;case"i":type="<i32>";break;case"u":type="<u32>";break}}return`vec${vecSize}${type}`}}else if(value.startsWith("mat")){const MatMatch=value.match(/mat(\d+)x(\d+)(f|h|i|u|<[^>]+>)?/);if(MatMatch){const matSize=`${MatMatch[1]}x${MatMatch[2]}`;let type=MatMatch[3];if(!type){type="<f32>"}else if(type.length===1){switch(type){case"f":type="<f32>";break;case"h":type="<f16>";break;default:type="<f32>"}}return`mat${matSize}${type}`}}else if(value.startsWith("[")){const firstElement=value.split(",")[0].substring(1);if(firstElement==="]")return"array<f32>";if(firstElement.startsWith("[")&&!firstElement.endsWith("]")){return this.inferTypeFromValue(firstElement,funcStr,ast)}else{if(firstElement.startsWith("vec")||firstElement.startsWith("mat")){return`array<${this.inferTypeFromValue(firstElement,funcStr,ast)}>`}else if(firstElement.includes(".")){return"array<f32>"}else if(!isNaN(firstElement)){return"array<i32>"}}}else if(value.startsWith("new Array")){const arrayNameMatch=value.match(/let\s+(\w+)\s*=/);if(arrayNameMatch){const arrayName=arrayNameMatch[1];const assignmentMatch=funcStr.match(new RegExp(`${arrayName}\\[\\d+\\]\\s*=\\s*(.+?);`));if(assignmentMatch){return this.inferTypeFromValue(assignmentMatch[1],funcStr,ast)}}else return"f32"}else if(value.startsWith("new Float32Array")){return"array<f32>"}else if(value.startsWith("new Float64Array")){return"array<f64>"}else if(value.startsWith("new Int8Array")){return"array<i8>"}else if(value.startsWith("new Int16Array")){return"array<i16>"}else if(value.startsWith("new Int32Array")){return"array<i32>"}else if(value.startsWith("new BigInt64Array")){return"array<i64>"}else if(value.startsWith("new BigUInt64Array")){return"array<u64>"}else if(value.startsWith("new Uint8Array")||value.startsWith("new Uint8ClampedArray")){return"array<u8>"}else if(value.startsWith("new Uint16Array")){return"array<u16>"}else if(value.startsWith("new Uint32Array")){return"array<u32>"}else if(value.includes(".")||value.includes("e-")){return"f32"}else if(!isNaN(value)){return"i32"}else{const astNode=ast.find(node=>node.name===value);if(astNode){if(astNode.type==="array"){return"f32"}else if(astNode.type==="variable"){return this.inferTypeFromValue(astNode.value,funcStr,ast)}}}return defaultValue}static flattenStrings(arr){if(!arr)return[];const callback=(item,index,array)=>{if(item.startsWith("[")&&item.endsWith("]")){return item.slice(1,-1).split(",").map(s=>s.trim())}return item};return arr.reduce((acc,value,index,array)=>{return acc.concat(callback(value,index,array))},[])}static generateDataStructures(funcStr,ast,bindGroup=0,shaderType,variableTypes,minBinding=0){let code="//Bindings (data passed to/from CPU) \n";const functionRegex=/function (\w+)\(([^()]*|\((?:[^()]*|\([^()]*\))*\))*\) \{([\s\S]*?)\}/g;let modifiedStr=funcStr;let match;while((match=functionRegex.exec(funcStr))!==null){modifiedStr=modifiedStr.replace(match[3],"PLACEHOLDER")}const returnMatches=modifiedStr.match(/^(?![ \t]*\/\/).*\breturn .*;/gm);let returnedVars=returnMatches?returnMatches.map(match2=>match2.replace(/^[ \t]*return /,"").replace(";","")):void 0;returnedVars=this.flattenStrings(returnedVars);let uniformsStruct="";let defaultsStruct="";let hasUniforms=false;let defaultUniforms;const params=[];let bindingIncr=minBinding;let names={};let prevTextureBinding;ast.forEach((node,i)=>{if(names[node.name])return;names[node.name]=true;if(returnedVars.includes(node.name)&&!this.excludedNames[node.name])node.isInput=true;function escapeRegExp(string){return string.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}if(new RegExp(`textureSampleCompare\\(${escapeRegExp(node.name)},`).test(funcStr)){let nm=node.name.toLowerCase();if(nm.includes("deptharr"))node.isDepthTextureArray=true;else if(nm.includes("depth"))node.isDepthTexture2d=true;else if(nm.includes("cubearr"))node.isDepthCubeArrayTexture=true;else if(nm.includes("cube"))node.isDepthCubeTexture=true;else if(nm.includes("ms2d"))node.isDepthMSAATexture=true;node.isTexture=true;node.isDepthTexture=true;prevTextureBinding=bindingIncr}else if(new RegExp(`textureSampleCompare\\(\\w+\\s*,\\s*${escapeRegExp(node.name)}`).test(funcStr)){node.isComparisonSampler=true;node.isSampler=true}else if(new RegExp(`textureSample\\(\\w+\\s*,\\s*${escapeRegExp(node.name)}`).test(funcStr)){node.isSampler=true}else if(new RegExp(`textureStore\\(${escapeRegExp(node.name)},`).test(funcStr)){let nm=node.name.toLowerCase();if(nm.includes("3d"))node.is3dStorageTexture=true;else if(nm.includes("1d"))node.is1dStorageTexture=true;else if(nm.includes("2darr"))node.is2dStorageTextureArray=true;node.isStorageTexture=true;if(prevTextureBinding!==void 0)node.isSharedStorageTexture=true}else if(new RegExp(`texture.*\\(${escapeRegExp(node.name)},`).test(funcStr)){let nm=node.name.toLowerCase();if(nm.includes("deptharr"))node.isDepthTextureArray=true;else if(nm.includes("depthcubearr"))node.isDepthCubeArrayTexture=true;else if(nm.includes("depthcube"))node.isDepthCubeTexture=true;else if(nm.includes("depthms2d"))node.isDepthMSAATexture=true;else if(nm.includes("depth"))node.isDepthTexture2d=true;else if(nm.includes("cubearr"))node.isCubeArrayTexture=true;else if(nm.includes("cube"))node.isCubeTexture=true;else if(nm.includes("3d"))node.is3dTexture=true;else if(nm.includes("2darr"))node.is2dTextureArray=true;else if(nm.includes("1d"))node.is1dTexture=true;else if(nm.includes("ms2d"))node.is2dMSAATexture=true;if(nm.includes("depth"))node.isDepthTexture=true;node.isTexture=true;prevTextureBinding=bindingIncr}node.binding=bindingIncr;node.group=bindGroup;if(variableTypes&&variableTypes[node.name]){if(typeof variableTypes[node.name]==="string"){code+=`@group(${bindGroup}) @binding(${bindingIncr}) var ${node.name}: ${variableTypes[node.name]};

`;node.type=variableTypes[node.name];bindingIncr++;params.push(node)}else if(typeof variableTypes[node.name]==="object"){code+=`@group(${bindGroup}) @binding(${bindingIncr}) ${variableTypes[node.name].prefix||"var"} ${node.name}: ${variableTypes[node.name].type};

`;node.type=variableTypes[node.name].type;bindingIncr++;params.push(node)}}else if(node.isTexture){params.push(node);let format=node.name.includes("i32")?"i32":node.name.includes("u32")?"u32":"f32";let typ;if(node.isDepthTextureArray)typ="texture_depth_2d_array";else if(node.isDepthCubeArrayTexture)typ="texture_depth_cube_array";else if(node.isDepthMSAATexture)typ="texture_depth_multisampled_2d";else if(node.isDepthCubeTexture)typ="texture_depth_cube";else if(node.isDepthTexture2d)typ="texture_depth_2d";else if(node.isCubeArrayTexture)typ="texture_cube_array<"+format+">";else if(node.isCubeTexture)typ="texture_cube<"+format+">";else if(node.is3dTexture)typ="texture_3d<"+format+">";else if(node.is2dTextureArray)typ="texture_2d_array<"+format+">";else if(node.is1dTexture)typ="texture_1d<"+format+">";else if(node.is2dMSAATexture)typ="texture_multisampled_2d<"+format+">";else typ=`texture_2d<f32>`;code+=`@group(${bindGroup}) @binding(${bindingIncr}) var ${node.name}: ${typ};
`;bindingIncr++}else if(node.isStorageTexture){let format=textureFormats.find(f=>{if(node.name.includes(f))return true});if(!format)format="rgba8unorm";let typ;if(node.is3dStorageTexture)typ="texture_storage_3d<"+format+",write>";else if(node.is1dStorageTexture)typ="texture_storage_3d<"+format+",write>";else if(node.is2dStorageTextureArray)typ="texture_storage_2d_array<"+format+",write>";else typ="texture_storage_2d<"+format+",write>";params.push(node);code+=`@group(${bindGroup}) @binding(${bindingIncr}) var ${node.name}: ${typ};
`;if(typeof prevTextureBinding==="undefined")bindingIncr++;else prevTextureBinding=void 0}else if(node.isSampler){let typ;if(node.isComparisonSampler)typ="sampler_comparison";else typ="sampler";params.push(node);code+=`@group(${bindGroup}) @binding(${bindingIncr}) var ${node.name}: ${typ};

`;bindingIncr++}else if(node.isInput&&!this.builtInUniforms[node.name]){if(node.type==="array"){const elementType=this.inferTypeFromValue(node.value.split(",")[0],funcStr,ast);node.type=elementType;params.push(node);code+=`struct ${capitalizeFirstLetter(node.name)}Struct {
    values: ${elementType}
};

`;code+=`@group(${bindGroup}) @binding(${bindingIncr})
`;if(!returnedVars||returnedVars?.includes(node.name)||node.isModified&&!node.isUniform){code+=`var<storage, read_write> ${node.name}: ${capitalizeFirstLetter(node.name)}Struct;

`}else{code+=`var<storage, read> ${node.name}: ${capitalizeFirstLetter(node.name)}Struct;

`}bindingIncr++}else if(node.isUniform){if(!hasUniforms){uniformsStruct=`struct UniformsStruct {
`;hasUniforms=bindingIncr;bindingIncr++}const uniformType=this.inferTypeFromValue(node.value,funcStr,ast);node.type=uniformType;params.push(node);uniformsStruct+=`    ${node.name}: ${uniformType},
`}}else if(this.builtInUniforms[node.name]){if(!defaultUniforms){defaultUniforms=[];defaultsStruct=`struct DefaultUniforms {
`}const uniformType=this.builtInUniforms[node.name].type;defaultsStruct+=`    ${node.name}: ${uniformType},
`;defaultUniforms.push(node.name)}});if(defaultUniforms){defaultsStruct+="};\n\n";code+=defaultsStruct;code+=`@group(${bindGroup}) @binding(${bindingIncr}) var<uniform> defaults: DefaultUniforms;

`;bindingIncr++}if(hasUniforms!==false){uniformsStruct+="};\n\n";code+=uniformsStruct;code+=`@group(${bindGroup}) @binding(${hasUniforms}) var<uniform> uniforms: UniformsStruct;

`}return{code,params,defaultUniforms,lastBinding:bindingIncr}}static extractAndTransposeInnerFunctions=(body,extract=true,ast,params,shaderType,vertexBufferOptions)=>{const functionRegex=/function (\w+)\(([^()]*|\((?:[^()]*|\([^()]*\))*\))*\) \{([\s\S]*?)\}/g;let match;let extractedFunctions="";while((match=functionRegex.exec(body))!==null){const functionHead=match[0];const funcName=match[1];const funcBody=match[3];let paramString=functionHead.substring(functionHead.indexOf("(")+1,functionHead.lastIndexOf(")"));let outputParam;const regex=/return\s+([\s\S]*?);/;const retmatch=body.match(regex);if(retmatch){let inferredType=this.inferTypeFromValue(retmatch[1],body,ast,false);if(inferredType){outputParam=inferredType}}let params2=this.splitIgnoringBrackets(paramString).map(p=>{let split=p.split("=");let vname=split[0];let inferredType=this.inferTypeFromValue(split[1],body,ast);if(!outputParam)outputParam=inferredType;return vname+": "+inferredType});const transposedBody=this.transposeBody(funcBody,funcBody,params2,shaderType,true,void 0,false,vertexBufferOptions).code;extractedFunctions+=`fn ${funcName}(${params2}) -> ${outputParam} {${transposedBody}}

`}if(extract)body=body.replace(functionRegex,"");return{body,extractedFunctions}};static generateMainFunctionWorkGroup(funcStr,ast,params,shaderType="compute",vertexBufferOptions=[{color:"vec4<f32>"}],workGroupSize=64,gpuFuncs){let code="";if(gpuFuncs){gpuFuncs.forEach(f=>{let result=this.extractAndTransposeInnerFunctions(typeof f==="function"?f.toString():f,false,ast,params,shaderType,vertexBufferOptions);if(result.extractedFunctions)code+=result.extractedFunctions})}const{body:mainBody,extractedFunctions}=this.extractAndTransposeInnerFunctions(funcStr.match(/{([\s\S]+)}/)[1],true,ast,params,shaderType,vertexBufferOptions);code+=extractedFunctions;let vtxInps;let vboInputStrings=[];if(shaderType==="vertex"||shaderType==="fragment"){let vboStrings=[];if(vertexBufferOptions){const types=[];const keys=[];vertexBufferOptions.forEach(obj=>{keys.push(...Object.keys(obj));types.push(...Object.values(obj))});let loc=0;let idx=0;for(const key of keys){const type=types[idx];idx++;if(key==="stepMode"||key==="__COUNT")continue;vboStrings.push(`@location(${loc}) ${key}: ${type}${idx===keys.length?"":","}`);if(shaderType==="vertex"){vboInputStrings.push(`@location(${loc}) ${key}In: ${type}${idx===keys.length?"":","}`)}loc++}}vtxInps=`
    @builtin(position) position: vec4<f32>, //pixel location
    //uploaded vertices from CPU, in interleaved format
${vboStrings.join("\n")}`;code+=`
struct Vertex {
    ${vtxInps}
};
`}if(shaderType==="compute"){code+=`
//Main function call
//threadId tells us what x,y,z thread we are on

@compute @workgroup_size(${workGroupSize})
fn compute_main(  
    @builtin(global_invocation_id) threadId: vec3<u32>, //shader grid position
    @builtin(local_invocation_id) localId: vec3<u32>,   //workgroup grid position
    @builtin(local_invocation_index) localIndex: u32,   //linear index within workgroup grid
    @builtin(num_workgroups) workgroups: vec3<u32>,     //dispatch size (x,y,z) group count
    @builtin(workgroup_id) workgroupId: vec3<u32>       //position of workgroup in compute shader grid`;code+="\n) {\n"}else if(shaderType==="vertex"){code+=`
@vertex
fn vtx_main(
    @builtin(vertex_index) vertexIndex : u32,   //current vertex
    @builtin(instance_index) instanceIndex: u32, //current instance
    ${vboInputStrings.join("\n")}`;code+="\n) -> Vertex {\n    var pixel: Vertex;\n"}else if(shaderType==="fragment"){code+=`
@fragment
fn frag_main(
    pixel: Vertex,
    @builtin(front_facing) is_front: bool,   //true when current fragment is on front-facing primitive
    @builtin(sample_index) sampleIndex: u32, //sample index for the current fragment
    @builtin(sample_mask) sampleMask: u32   //contains a bitmask indicating which samples in this fragment are covered by the primitive being rendered
) -> @location(0) vec4<f32> {
`}let shaderHead=code;let transposed=this.transposeBody(mainBody,funcStr,params,shaderType,shaderType==="fragment",shaderHead,true,vertexBufferOptions);code+=transposed.code;if(transposed.consts?.length>0)code=transposed.consts.join("\n")+"\n\n"+code;if(shaderType==="vertex")code+=`
    return pixel; 
`;code+="\n}\n";return code}static transposeBody=(body,funcStr,params,shaderType,returns=false,shaderHead="",extractConsts=false,vertexBufferOptions)=>{let code="";const commentPlaceholders={};let placeholderIndex=0;body=body.replace(/\/\/.*$/gm,match=>{const placeholder=`__COMMENT_PLACEHOLDER_${placeholderIndex}__`;commentPlaceholders[placeholder]=match;placeholderIndex++;return placeholder});code=body.replace(/for \((let|var) (\w+) = ([^;]+); ([^;]+); ([^\)]+)\)/gm,"for (var $2 = $3; $4; $5)");const stringPlaceholders={};let stringPlaceholderIndex=0;code=code.replace(/('|"|`)([\s\S]*?)\1/gm,match=>{const placeholder=`__CODE_PLACEHOLDER_${stringPlaceholderIndex}__`;stringPlaceholders[placeholder]=match.substring(1,match.length-1);stringPlaceholderIndex++;return placeholder});code=code.replace(/const (\w+) = (?!(vec\d+|mat\d+|\[.*|array))/gm,"let $1 = ");const vecMatDeclarationRegex=/(let|var) (\w+) = (vec\d+|mat\d+)/gm;code=code.replace(vecMatDeclarationRegex,"var $2 = $3");const vecMatDeclarationRegex2=/const (\w+) = (vec\d+|mat\d+)/gm;code=code.replace(vecMatDeclarationRegex2,"const $2 = $3");const arrayVars=[];code.replace(/(let|var|const) (\w+) = (array|\[)/gm,(match,p1,varName)=>{arrayVars.push(varName);return match});if(shaderType!=="vertex"&&shaderType!=="fragment"){code=code.replace(/(\w+)\[([\w\s+\-*\/]+)\]/gm,(match,p1,p2)=>{if(arrayVars.includes(p1))return match;return`${p1}.values[${p2}]`})}else{let names=["position"];vertexBufferOptions.forEach(opt=>{names.push(...Object.keys(opt).filter(n=>{if(n!=="stepMode"&&n!=="__COUNT")return true}))});let namesPattern=names.join("|");code=code.replace(new RegExp(`(${namesPattern})|(\\w+)\\[([\\w\\s+\\-*\\/]+)\\]`,"gm"),(match,p1,p2,p3)=>{if(p1||arrayVars.includes(p2))return match;return`${p2}.values[${p3}]`})}code=code.replace(/(\w+)\.length/gm,"arrayLength(&$1.values)");code=code.replace(/(\/\/[^\n]*);/gm,"$1");code=code.replace(/(let|var|const) (\w+) = \[([\s\S]*?)\];/gm,(match,varType,varName,values)=>{const valuesLines=values.trim().split("\n");const vals=[];const cleanedValues=valuesLines.map(line=>{let cleaned=line.substring(0,line.indexOf("//")>0?line.indexOf("//"):void 0);cleaned=cleaned.substring(0,line.indexOf("__CO")>0?line.indexOf("__COMM"):void 0);vals.push(line);return cleaned?.indexOf(",")<0?cleaned+",":cleaned}).join("\n");const valuesWithoutComments=cleanedValues.replace(/\/\*.*?\*\//gm,"").trim();const valuesArray=this.splitIgnoringBrackets(valuesWithoutComments);const size=valuesArray.length;const hasDecimal=valuesWithoutComments.includes(".");const isVecWithF=/^vec\d+f/.test(valuesWithoutComments);const inferredType=valuesWithoutComments.startsWith("mat")||hasDecimal||isVecWithF?"f32":"i32";let arrayValueType=inferredType;const arrayValueTypeMatch=valuesWithoutComments.match(/^(vec\d+f?|mat\d+x\d+)/gm);if(arrayValueTypeMatch){arrayValueType=arrayValueTypeMatch[0]}return`${varType} ${varName} : array<${arrayValueType}, ${size}> = array<${arrayValueType}, ${size}>(
${vals.join("\n")}
);`});function transformArrays(input){let lines=input.split("\n");let output=[];function countCharacter(str,char){return str.split(char).length-1}function extractFillValue(line){let startIndex=line.indexOf(".fill(")+6;let parenthesesCount=1;let endIndex=startIndex;while(parenthesesCount!==0&&endIndex<line.length){endIndex++;if(line[endIndex]==="("){parenthesesCount++}else if(line[endIndex]===")"){parenthesesCount--}}return line.substring(startIndex,endIndex)}for(let line of lines){line=line.trim();let transformedLine=line;if(/^(let|const|var)\s/.test(line)&&line.includes(".fill(")){let variableName=line.split("=")[0].trim().split(" ")[1];let size=line.split("new Array(")[1].split(")")[0].trim();let fillValue=extractFillValue(line);let sizeCount=countCharacter(size,"(")-countCharacter(size,")");for(let i=0;i<sizeCount;i++)size+=")";if(fillValue.startsWith("vec")){let isVecWithF=/vec\d+f/.test(fillValue);let vecType=isVecWithF||fillValue.match(/\.\d+/)?"f32":"i32";transformedLine=`var ${variableName} : array<${fillValue.split("(")[0]}<${vecType}>, ${size}>;
for (var i: i32 = 0; i < ${size}; i = i + 1) {
	${variableName}[i] = ${fillValue.replace(fillValue.split("(")[0],fillValue.split("(")[0]+`<${vecType}>`)};
}`}else if(fillValue.startsWith("mat")){transformedLine=`var ${variableName} : array<${fillValue.split("(")[0]}<f32>, ${size}>;
for (var i: i32 = 0; i < ${size}; i = i + 1) {
	${variableName}[i] = ${fillValue.replace(/vec(\d)/g,"vec$1<f32>")};
}`}else{transformedLine=`var ${variableName} : array<f32, ${size}>;
for (var i: i32 = 0; i < ${size}; i = i + 1) {
	${variableName}[i] = ${fillValue};
}`}}output.push(transformedLine)}return output.join("\n")}code=transformArrays(code);code=code.replace(/(let|var|const) (\w+) = new (Float|Int|UInt)(\d+)Array\((\d+)\);/gm,(match,keyword,varName,typePrefix,bitSize,arraySize)=>{let typeChar;switch(typePrefix){case"Float":typeChar="f";break;case"Int":typeChar="i";break;case"UInt":typeChar="u";break;default:typeChar="f"}return`var ${varName} : array<${typeChar}${bitSize}, ${arraySize}>;`});code=code.replace(/(let|var|const) (\w+) = new Array\((\d+)\);/gm,"var $2 : array<f32, $2>;");code=replaceJSFunctions(code,replacements);const vecMatCreationRegex=/(vec(\d+)|mat(\d+))\(([^)]+)\)/gm;code=code.replace(vecMatCreationRegex,(match,type,vecSize,matSize,args)=>{const argArray=args.split(",").map(arg=>arg.trim());const hasDecimal=argArray.some(arg=>arg.includes("."));const isVecOrMatWithSpecificType=/^(vec|mat)\d+[fuhi]/.test(type);let inferredType;if(isVecOrMatWithSpecificType){const typeSuffix=type.match(/[fuhi]$/)[0];switch(typeSuffix){case"f":inferredType="f32";break;case"u":inferredType="u32";break;case"i":inferredType="i32";break;case"h":inferredType="f16";break;default:inferredType="f32"}}else{inferredType=hasDecimal?"f32":"i32"}if(type.startsWith("mat")){const matInternalType=isVecOrMatWithSpecificType?`<${inferredType}>`:"<f32>";return`${type}${matInternalType}(${argArray.join(", ").replace(/vec(\d+)/gm,`vec$1${matInternalType}`)})`}else{return`${type}<${inferredType}>(${argArray.join(", ")})`}});params.forEach(param=>{if(param.isUniform){const regex=new RegExp(`(?<![a-zA-Z0-9])${param.name}(?![a-zA-Z0-9])`,"gm");code=code.replace(regex,`uniforms.${param.name}`)}});Object.keys(this.builtInUniforms).forEach(param=>{const regex=new RegExp(`(?<![a-zA-Z0-9])${param}(?![a-zA-Z0-9])`,"gm");code=code.replace(regex,`defaults.${param}`)});for(const[placeholder,comment]of Object.entries(commentPlaceholders)){code=code.replace(placeholder,comment)}for(const[placeholder,str]of Object.entries(stringPlaceholders)){code=code.replace(placeholder,str)}if(shaderType==="fragment"||shaderType==="vertex"){const vertexVarMatches=shaderHead.match(/@location\(\d+\) (\w+):/gm);const vertexVars=vertexVarMatches?vertexVarMatches.map(match=>{const parts=match.split(" ");return parts[1].replace(":","")}):[];vertexVars.push("position");vertexVars.forEach(varName=>{if(!varName.includes("In")){const regex=new RegExp(`(?<![a-zA-Z0-9_.])${varName}(?![a-zA-Z0-9_.])`,"gm");code=code.replace(regex,`pixel.${varName}`)}})}code=code.replace(/^(.*[^;\s\{\[\(\,\>\}])(\s*\/\/.*)$/gm,"$1;$2");code=code.replace(/^(.*[^;\s\{\[\(\,\>\}])(?!\s*\/\/)(?=\s*$)/gm,"$1;");code=code.replace(/(\/\/[^\n]*);/gm,"$1");code=code.replace(/;([^\n]*)\s*(\n\s*)\)/gm,"$1$2)");let consts;if(extractConsts){let extrConsts=function(text){const pattern=/const\s+[a-zA-Z_][a-zA-Z0-9_]*\s*:\s*[a-zA-Z_][a-zA-Z0-9_<>,\s]*\s*=\s*[a-zA-Z_][a-zA-Z0-9_<>,\s]*(\([\s\S]*?\)|\d+\.?\d*);/gm;let match;const extractedConsts=[];while((match=pattern.exec(text))!==null){extractedConsts.push(match[0])}const pattern2=/const\s+[a-zA-Z_][a-zA-Z0-9_]*\s*=\s*[a-zA-Z_][a-zA-Z0-9_]*\s*\([\s\S]*?\)\s*;/gm;while((match=pattern2.exec(text))!==null){extractedConsts.push(match[0])}const modifiedText=text.replace(pattern,"").replace(pattern2,"").trim();return{consts:extractedConsts,code:modifiedText}};let extracted=extrConsts(code);code=extracted.code;consts=extracted.consts}if(!returns)code=code.replace(/(return [^;]+;)/gm,"//$1");return{code,consts}};static indentCode(code){let depth=0;const tab="    ";let result="";let needsIndent=false;let leadingSpaceDetected=false;for(let i=0;i<code.length;i++){const char=code[i];if(char==="\n"){result+=char;needsIndent=true;leadingSpaceDetected=false;continue}if(char===" "&&needsIndent){leadingSpaceDetected=true}if(needsIndent&&!leadingSpaceDetected){result+=tab.repeat(depth);needsIndent=false}if(char==="{"||char==="("){depth++}if(char==="}"||char===")"){if(depth>0)depth--;if(result.slice(-tab.length)===tab){result=result.slice(0,-tab.length)}}result+=char}return result}static addFunction=(func,shaders)=>{if(!shaders.functions)shaders.functions=[];shaders.functions.push(func);for(const key of["compute","fragment","vertex"]){if(shaders[key])Object.assign(shaders[key],this.convertToWebGPU(shaders[key].funcStr,key,shaders[key].bindGroupNumber,shaders[key].nVertexBuffers,shaders[key].workGroupSize?shaders[key].workGroupSize:void 0,shaders.functions))}return shaders};static combineBindings(bindings1str,bindings2str){const bindingRegex=/@group\((\d+)\) @binding\((\d+)\)\s+(var(?:<[^>]+>)?)\s+(\w+)\s*:/g;const structRegex=/struct (\w+) \{([\s\S]*?)\}/;const combinedStructs=new Map;const replacementsOriginal=new Map;const replacementsReplacement=new Map;let changesShader1={};let changesShader2={};let usedBindings=new Set;let bmatch;while((bmatch=bindingRegex.exec(bindings1str))!==null){usedBindings.add(`${bmatch[1]}-${bmatch[2]}`)}bindings2str=bindings2str.replace(bindingRegex,(match2,group,binding,varDecl,varName)=>{let newBinding=binding;while(usedBindings.has(`${group}-${newBinding}`)){newBinding=(parseInt(newBinding)+1).toString();changesShader2[varName]={group,binding:newBinding}}usedBindings.add(`${group}-${newBinding}`);return`@group(${group}) @binding(${newBinding}) ${varDecl} ${varName}:`});const extractBindings=(str,replacements2,changes)=>{let match2;const regex=new RegExp(bindingRegex);while((match2=regex.exec(str))!==null){replacements2.set(match2[4],match2[0].slice(0,match2[0].indexOf(" var")));changes[match2[4]]={group:match2[1],binding:match2[2]};usedBindings.add(`${match2[1]}-${match2[2]}`)}};extractBindings(bindings1str,replacementsOriginal,changesShader1);extractBindings(bindings2str,replacementsReplacement,changesShader2);let match=structRegex.exec(bindings1str);if(match){const fields=match[2].trim().split(",\n").map(field=>field.trim());combinedStructs.set(match[1],fields)}match=structRegex.exec(bindings2str);if(match){const fields=match[2].trim().split(",\n").map(field=>field.trim());const existing=combinedStructs.get(match[1])||[];fields.forEach(field=>{const fieldName=field.split(":")[0].trim();if(!existing.some(e=>e.startsWith(fieldName))){existing.push(field)}});combinedStructs.set(match[1],existing)}const constructCombinedStruct=structName=>{if(combinedStructs.has(structName)){return`struct ${structName} {
    ${combinedStructs.get(structName).join(",\n    ")}
};
`}return""};const result1=bindings1str.replace(/struct UniformStruct \{[\s\S]*?\};/g,()=>constructCombinedStruct("UniformStruct")).replace(bindingRegex,match2=>{const varName=match2.split(" ").pop().split(":")[0];if(replacementsReplacement.has(varName)){const updated=replacementsOriginal.get(varName)+" "+match2.split(" ").slice(-2).join(" ");const newGroup=updated.match(/@group\((\d+)\)/)[1];const newBinding=updated.match(/@binding\((\d+)\)/)[1];changesShader1[varName]={group:newGroup,binding:newBinding};return updated}return match2});const result2=bindings2str.replace(/struct UniformStruct \{[\s\S]*?\};/g,()=>constructCombinedStruct("UniformStruct")).replace(bindingRegex,match2=>{const varName=match2.split(" ").pop().split(":")[0];if(replacementsOriginal.has(varName)){const updated=replacementsOriginal.get(varName)+" "+match2.split(" ").slice(-2).join(" ");const newGroup=updated.match(/@group\((\d+)\)/)[1];const newBinding=updated.match(/@binding\((\d+)\)/)[1];changesShader2[varName]={group:newGroup,binding:newBinding};return updated}return match2});return{code1:result1.trim(),changes1:changesShader1,code2:result2.trim(),changes2:changesShader2}}static combineShaderParams(shader1Obj,shader2Obj){let combinedAst=shader2Obj.ast?[...shader2Obj.ast]:[];let combinedParams=shader2Obj.params?[...shader2Obj.params]:[];let combinedReturnedVars=[];const returnMatches=shader2Obj.funcStr.match(/^(?![ \t]*\/\/).*\breturn .*;/gm);if(returnMatches){const returnedVars=returnMatches.map(match=>match.replace(/^[ \t]*return /,"").replace(";",""));combinedReturnedVars.push(..._WGSLTranspiler.flattenStrings(returnedVars))}const returnMatches2=shader1Obj.funcStr.match(/^(?![ \t]*\/\/).*\breturn .*;/gm);if(returnMatches2){const returnedVars2=returnMatches2.map(match=>match.replace(/^[ \t]*return /,"").replace(";",""));combinedReturnedVars.push(..._WGSLTranspiler.flattenStrings(returnedVars2))}if(shader1Obj.ast)combinedAst.push(...shader1Obj.ast);if(shader1Obj.params)combinedParams.push(...shader1Obj.params);const uniqueBindings=new Set;const updatedParams=[];const bindingMap2=new Map;shader1Obj.params.forEach((entry,i)=>{if(shader2Obj.params.some(param=>param.name===entry.name)&&!uniqueBindings.has(entry.name)){uniqueBindings.add(entry.name);const newBinding=i;updatedParams.push(entry);bindingMap2.set(entry.binding,newBinding)}});let maxSharedBinding=uniqueBindings.size-1;shader2Obj.params.forEach((entry,i)=>{if(!shader1Obj.params.some(param=>param.name===entry.name)&&!uniqueBindings.has(entry.name)){uniqueBindings.add(i);maxSharedBinding++;updatedParams.push(entry);bindingMap2.set(entry.binding,maxSharedBinding)}});combinedParams=updatedParams;let shaderCode2=shader2Obj.code;for(let[oldBinding,newBinding]of bindingMap2.entries()){const regex=new RegExp(`@binding\\(${oldBinding}\\)`,"g");shaderCode2=shaderCode2.replace(regex,`@binding(${newBinding})`)}shader2Obj.code=shaderCode2;shader1Obj.ast=combinedAst;shader1Obj.returnedVars=combinedReturnedVars;shader1Obj.params=combinedParams;shader2Obj.ast=combinedAst;shader2Obj.returnedVars=combinedReturnedVars;shader2Obj.params=combinedParams}static convertToWebGPU(func,shaderType="compute",bindGroupNumber=0,workGroupSize=64,vertexBufferOptions=[{color:"vec4<f32>"}],gpuFuncs,variableTypes,lastBinding=0){let funcStr=typeof func==="string"?func:func.toString();funcStr=funcStr.replace(/(?<!\w)this\./g,"");const tokens=this.tokenize(funcStr);const ast=this.parse(funcStr,tokens,shaderType,vertexBufferOptions);let webGPUCode=this.generateDataStructures(funcStr,ast,bindGroupNumber,shaderType,variableTypes,lastBinding);const header=webGPUCode.code;webGPUCode.code+="\n"+this.generateMainFunctionWorkGroup(funcStr,ast,webGPUCode.params,shaderType,vertexBufferOptions,workGroupSize,gpuFuncs);return{code:this.indentCode(webGPUCode.code),header,ast,params:webGPUCode.params,funcStr,defaultUniforms:webGPUCode.defaultUniforms,type:shaderType,workGroupSize:shaderType==="compute"?workGroupSize:void 0,bindGroupNumber,lastBinding:webGPUCode.lastBinding}}};function capitalizeFirstLetter(string){return string.charAt(0).toUpperCase()+string.slice(1)}function replaceJSFunctions(code,replacements2){for(let[jsFunc,shaderFunc]of Object.entries(replacements2)){const regex=new RegExp(jsFunc.replace(".","\\."),"g");code=code.replace(regex,shaderFunc)}return code}var replacements={"Math.PI":`${Math.PI}`,"Math.E":`${Math.E}`,"Math.LN10":`${Math.LN10}`,"Math.LN2":`${Math.LN2}`,"Math.LOG10E":`${Math.LOG10E}`,"Math.LOG2E":`${Math.LOG2E}`,"Math.SQRT1_2":`${Math.SQRT1_2}`,"Math.SQRT2":`${Math.SQRT2}`,"Math.abs":"abs","Math.acos":"acos","Math.acosh":"acosh","Math.asin":"asin","Math.asinh":"asinh","Math.atan":"atan","Math.atan2":"atan2","Math.atanh":"atanh","Math.ceil":"ceil","Math.cos":"cos","Math.cosh":"cosh","Math.clz32":"countLeadingZeros","Math.exp":"exp","Math.floor":"floor","Math.log":"log","Math.log2":"log2","Math.max":"max","Math.min":"min","Math.pow":"pow","Math.round":"round","Math.sin":"sin","Math.sinh":"sinh","Math.sqrt":"sqrt","Math.tan":"tan","Math.tanh":"tanh","Math.trunc":"trunc"};var wgslTypeSizes32={"bool":{alignment:1,size:1,ct:1},"u8":{alignment:1,size:1,ct:1},"i8":{alignment:1,size:1,ct:1},"i32":{alignment:4,size:4,vertexFormats:{"sint32":true},ct:1},"u32":{alignment:4,size:4,vertexFormats:{"uint32":true},ct:1},"f32":{alignment:4,size:4,vertexFormats:{"float32":true},ct:1},"i64":{alignment:8,size:8,ct:1},"u64":{alignment:8,size:8,ct:1},"f64":{alignment:8,size:8,ct:1},"atomic<u32>":{alignment:4,size:4,ct:1},"atomic<i32>":{alignment:4,size:4,ct:1},"vec2<i32>":{alignment:8,size:8,vertexFormats:{"sint8x2":true,"sint16x2":true,"sint32x2":true},ct:2},"vec2<u32>":{alignment:8,size:8,vertexFormats:{"uint8x2":true,"uint16x2":true,"uint32x2":true},ct:2},"vec2<f32>":{alignment:8,size:8,vertexFormats:{"unorm8x2":true,"unorm16x2":true,"float32x2":true,"snorm8x2":true,"snorm16x2":true},ct:2},"vec3<i32>":{alignment:16,size:12,vertexFormats:{"sint32x3":true},ct:3},"vec3<u32>":{alignment:16,size:12,vertexFormats:{"uint32x3":true},ct:3},"vec3<f32>":{alignment:16,size:12,vertexFormats:{"float32x3":true},ct:3},"vec4<i32>":{alignment:16,size:16,vertexFormats:{"sint8x4":true,"sint16x4":true,"sint32x4":true},ct:4},"vec4<u32>":{alignment:16,size:16,vertexFormats:{"uint8x4":true,"uint16x4":true,"uint32x4":true},ct:4},"vec4<f32>":{alignment:16,size:16,vertexFormats:{"unorm8x4":true,"unorm16x4":true,"float32x4":true,"snorm8x4":true,"snorm16x4":true,"float16x4":true},ct:4},"vec2i":{alignment:8,size:8,vertexFormats:{"sint8x2":true,"sint16x2":true,"sint32x2":true},ct:2},"vec2u":{alignment:8,size:8,vertexFormats:{"uint8x2":true,"uint16x2":true,"uint32x2":true},ct:2},"vec2f":{alignment:8,size:8,vertexFormats:{"unorm8x2":true,"unorm16x2":true,"float32x2":true,"snorm8x2":true,"snorm16x2":true},ct:2},"vec3i":{alignment:16,size:12,vertexFormats:{"sint32x3":true},ct:3},"vec3u":{alignment:16,size:12,vertexFormats:{"uint32x3":true},ct:3},"vec3f":{alignment:16,size:12,vertexFormats:{"float32x3":true},ct:3},"vec4i":{alignment:16,size:16,vertexFormats:{"sint8x4":true,"sint16x4":true,"sint32x4":true},ct:4},"vec4u":{alignment:16,size:16,vertexFormats:{"uint8x4":true,"uint16x4":true,"uint32x4":true},ct:4},"vec4f":{alignment:16,size:16,vertexFormats:{"unorm8x4":true,"unorm16x4":true,"float32x4":true,"snorm8x4":true,"snorm16x4":true,"float16x4":true},ct:4},"mat2x2<f32>":{alignment:8,size:16,ct:4},"mat2x2<i32>":{alignment:8,size:16,ct:4},"mat2x2<u32>":{alignment:8,size:16,ct:4},"mat3x2<f32>":{alignment:8,size:24,ct:6},"mat3x2<i32>":{alignment:8,size:24,ct:6},"mat3x2<u32>":{alignment:8,size:24,ct:6},"mat4x2<f32>":{alignment:8,size:32,ct:8},"mat4x2<i32>":{alignment:8,size:32,ct:8},"mat4x2<u32>":{alignment:8,size:32,ct:8},"mat2x3<f32>":{alignment:16,size:24,ct:6},"mat2x3<i32>":{alignment:16,size:24,ct:6},"mat2x3<u32>":{alignment:16,size:24,ct:6},"mat3x3<f32>":{alignment:16,size:36,ct:9},"mat3x3<i32>":{alignment:16,size:36,ct:9},"mat3x3<u32>":{alignment:16,size:36,ct:9},"mat4x3<f32>":{alignment:16,size:48,ct:12},"mat4x3<i32>":{alignment:16,size:48,ct:12},"mat4x3<u32>":{alignment:16,size:48,ct:12},"mat2x4<f32>":{alignment:16,size:32,ct:8},"mat2x4<i32>":{alignment:16,size:32,ct:8},"mat2x4<u32>":{alignment:16,size:32,ct:8},"mat3x4<f32>":{alignment:16,size:48,ct:12},"mat3x4<i32>":{alignment:16,size:48,ct:12},"mat3x4<u32>":{alignment:16,size:48,ct:12},"mat4x4<f32>":{alignment:16,size:64,ct:16},"mat4x4<i32>":{alignment:16,size:64,ct:16},"mat4x4<u32>":{alignment:16,size:64,ct:16},"mat2x2f":{alignment:8,size:16,ct:4},"mat2x2i":{alignment:8,size:16,ct:4},"mat2x2u":{alignment:8,size:16,ct:4},"mat3x2f":{alignment:8,size:24,ct:6},"mat3x2i":{alignment:8,size:24,ct:6},"mat3x2u":{alignment:8,size:24,ct:6},"mat4x2f":{alignment:8,size:32,ct:8},"mat4x2i":{alignment:8,size:32,ct:8},"mat4x2u":{alignment:8,size:32,ct:8},"mat2x3f":{alignment:16,size:24,ct:6},"mat2x3i":{alignment:16,size:24,ct:6},"mat2x3u":{alignment:16,size:24,ct:6},"mat3x3f":{alignment:16,size:36,ct:9},"mat3x3i":{alignment:16,size:36,ct:9},"mat3x3u":{alignment:16,size:36,ct:9},"mat4x3f":{alignment:16,size:48,ct:12},"mat4x3i":{alignment:16,size:48,ct:12},"mat4x3u":{alignment:16,size:48,ct:12},"mat2x4f":{alignment:16,size:32,ct:8},"mat2x4i":{alignment:16,size:32,ct:8},"mat2x4u":{alignment:16,size:32,ct:8},"mat3x4f":{alignment:16,size:48,ct:12},"mat3x4i":{alignment:16,size:48,ct:12},"mat3x4u":{alignment:16,size:48,ct:12},"mat4x4f":{alignment:16,size:64,ct:16},"mat4x4i":{alignment:16,size:64,ct:16},"mat4x4u":{alignment:16,size:64,ct:16}};var wgslTypeSizes16={"i16":{alignment:2,size:2},"u16":{alignment:2,size:2},"f16":{alignment:2,size:2,vertexFormats:{"float16x2":true,"float16x4":true}},"vec2<f16>":{alignment:4,size:4,vertexFormats:{"float16x2":true}},"vec2<i16>":{alignment:4,size:4},"vec2<u16>":{alignment:4,size:4},"vec3<f16>":{alignment:8,size:6},"vec3<i16>":{alignment:8,size:6},"vec3<u16>":{alignment:8,size:6},"vec4<f16>":{alignment:8,size:8,vertexFormats:{"float16x4":true}},"vec4<i16>":{alignment:8,size:8},"vec4<u16>":{alignment:8,size:8},"mat2x2<f16>":{alignment:4,size:8},"mat2x2<i16>":{alignment:4,size:8},"mat2x2<u16>":{alignment:4,size:8},"mat3x2<f16>":{alignment:4,size:12},"mat3x2<i16>":{alignment:4,size:12},"mat3x2<u16>":{alignment:4,size:12},"mat4x2<f16>":{alignment:4,size:16},"mat4x2<i16>":{alignment:4,size:16},"mat4x2<u16>":{alignment:4,size:16},"mat2x3<f16>":{alignment:8,size:16},"mat2x3<i16>":{alignment:8,size:16},"mat2x3<u16>":{alignment:8,size:16},"mat3x3<f16>":{alignment:8,size:24},"mat3x3<i16>":{alignment:8,size:24},"mat3x3<u16>":{alignment:8,size:24},"mat4x3<f16>":{alignment:8,size:32},"mat4x3<i16>":{alignment:8,size:32},"mat4x3<u16>":{alignment:8,size:32},"mat2x4<f16>":{alignment:8,size:16},"mat2x4<i16>":{alignment:8,size:16},"mat2x4<u16>":{alignment:8,size:16},"mat3x4<f16>":{alignment:8,size:24},"mat3x4<i16>":{alignment:8,size:24},"mat3x4<u16>":{alignment:8,size:24},"mat4x4<f16>":{alignment:8,size:32},"mat4x4<i16>":{alignment:8,size:32},"mat4x4<u16>":{alignment:8,size:32},"mat2x2h":{alignment:4,size:8},"mat3x2h":{alignment:4,size:12},"mat4x2h":{alignment:4,size:16},"mat2x3h":{alignment:8,size:16},"mat3x3h":{alignment:8,size:24},"mat4x3h":{alignment:8,size:32},"mat2x4h":{alignment:8,size:16},"mat3x4h":{alignment:8,size:24},"mat4x4h":{alignment:8,size:32}};var vertexFormats={"uint8x2":{byteSize:2,wgslTypes:{"vec2<u32>":true,"vec2u":true}},"uint8x4":{byteSize:4,wgslTypes:{"vec4<u32>":true,"vec4u":true}},"sint8x2":{byteSize:2,wgslTypes:{"vec2<i32>":true,"vec2i":true}},"sint8x4":{byteSize:4,wgslTypes:{"vec4<i32>":true,"vec4i":true}},"unorm8x2":{byteSize:2,wgslTypes:{"vec2<f32>":true,"vec2f":true}},"unorm8x4":{byteSize:4,wgslTypes:{"vec4<f32>":true,"vec4f":true}},"snorm8x2":{byteSize:2,wgslTypes:{"vec2<f32>":true,"vec2f":true}},"snorm8x4":{byteSize:4,wgslTypes:{"vec4<f32>":true,"vec4f":true}},"uint16x2":{byteSize:4,wgslTypes:{"vec2<u32>":true,"vec2u":true}},"uint16x4":{byteSize:8,wgslTypes:{"vec4<u32>":true,"vec4u":true}},"sint16x2":{byteSize:4,wgslTypes:{"vec2<i32>":true,"vec2i":true}},"sint16x4":{byteSize:8,wgslTypes:{"vec4<i32>":true,"vec4i":true}},"unorm16x2":{byteSize:4,wgslTypes:{"vec2<f32>":true,"vec2f":true}},"unorm16x4":{byteSize:8,wgslTypes:{"vec4<f32>":true,"vec4f":true}},"snorm16x2":{byteSize:4,wgslTypes:{"vec2<f32>":true,"vec2f":true}},"snorm16x4":{byteSize:8,wgslTypes:{"vec4<f32>":true,"vec4f":true}},"float16x2":{byteSize:4,wgslTypes:{"vec2<f16>":true,"vec2h":true}},"float16x4":{byteSize:8,wgslTypes:{"vec4<f16>":true,"vec4h":true}},"float32":{byteSize:4,wgslTypes:{"f32":true}},"float32x2":{byteSize:8,wgslTypes:{"vec2<f32>":true,"vec2f":true}},"float32x3":{byteSize:12,wgslTypes:{"vec3<f32>":true,"vec3f":true}},"float32x4":{byteSize:16,wgslTypes:{"vec4<f32>":true,"vec4f":true}},"uint32":{byteSize:4,wgslTypes:{"u32":true}},"uint32x2":{byteSize:8,wgslTypes:{"vec2<u32>":true,"vec2u":true}},"uint32x3":{byteSize:12,wgslTypes:{"vec3<u32>":true,"vec3u":true}},"uint32x4":{byteSize:16,wgslTypes:{"vec4<u32>":true,"vec4u":true}},"sint32":{byteSize:4,wgslTypes:{"i32":true}},"sint32x2":{byteSize:8,wgslTypes:{"vec2<i32>":true,"vec2i":true}},"sint32x3":{byteSize:12,wgslTypes:{"vec3<i32>":true,"vec3i":true}},"sint32x4":{byteSize:16,wgslTypes:{"vec4<i32>":true,"vec4i":true}}};var textureFormats=["r8unorm","r8snorm","r8uint","r8sint","r16uint","r16sint","r16float","rg8unorm","rg8snorm","rg8uint","rg8sint","r32uint","r32sint","r32float","rg16uint","rg16sint","rg16float","rgba8unorm","rgba8unorm-srgb","rgba8snorm","rgba8uint","rgba8sint","bgra8unorm","bgra8unorm-srgb","rgb9e5ufloat","rgb10a2uint","rgb10a2unorm","rg11b10ufloat","rg32uint","rg32sint","rg32float","rgba16uint","rgba16sint","rgba16float","rgba32uint","rgba32sint","rgba32float","stencil8","depth16unorm","depth24plus","depth24plus-stencil8","depth32float","depth32float-stencil8","bc1-rgba-unorm","bc1-rgba-unorm-srgb","bc2-rgba-unorm","bc2-rgba-unorm-srgb","bc3-rgba-unorm","bc3-rgba-unorm-srgb","bc4-r-unorm","bc4-r-snorm","bc5-rg-unorm","bc5-rg-snorm","bc6h-rgb-ufloat","bc6h-rgb-float","bc7-rgba-unorm","bc7-rgba-unorm-srgb","etc2-rgb8unorm","etc2-rgb8unorm-srgb","etc2-rgb8a1unorm","etc2-rgb8a1unorm-srgb","etc2-rgba8unorm","etc2-rgba8unorm-srgb","eac-r11unorm","eac-r11snorm","eac-rg11unorm","eac-rg11snorm","astc-4x4-unorm","astc-4x4-unorm-srgb","astc-5x4-unorm","astc-5x4-unorm-srgb","astc-5x5-unorm","astc-5x5-unorm-srgb","astc-6x5-unorm","astc-6x5-unorm-srgb","astc-6x6-unorm","astc-6x6-unorm-srgb","astc-8x5-unorm","astc-8x5-unorm-srgb","astc-8x6-unorm","astc-8x6-unorm-srgb","astc-8x8-unorm","astc-8x8-unorm-srgb","astc-10x5-unorm","astc-10x5-unorm-srgb","astc-10x6-unorm","astc-10x6-unorm-srgb","astc-10x8-unorm","astc-10x8-unorm-srgb","astc-10x10-unorm","astc-10x10-unorm-srgb","astc-12x10-unorm","astc-12x10-unorm-srgb","astc-12x12-unorm","astc-12x12-unorm-srgb"];var imageToTextureFormats={".png":["r8unorm","rg8unorm","rgba8unorm","rgba8unorm-srgb","rgb10a2unorm","bgra8unorm","bgra8unorm-srgb"],".jpg":["r8unorm","rg8unorm","rgba8unorm","rgba8unorm-srgb","rgb10a2unorm","bgra8unorm","bgra8unorm-srgb"],".hdr":["r16float","rg16float","rgba16float"],".exr":["r32float","rg32float","rgba32float"]};var WGSLTypeSizes=Object.assign({},wgslTypeSizes16,wgslTypeSizes32);for(const[key,value]of Object.entries(WGSLTypeSizes)){WGSLTypeSizes[key]={...value,type:key}}var ShaderHelper=class{prototypes={};compute;vertex;fragment;process=(...inputs)=>{const shader=this.compute;if(shader)return shader.run(this.compute.computePass,...inputs)};render=(renderPass,...inputs)=>{const shader=this.fragment?this.fragment:this.vertex;if(shader)return shader.run(renderPass?renderPass:shader.renderPass?shader.renderPass:{vertexCount:1},...inputs)};canvas;context;device;functions=[];bindGroupLayouts=[];bindGroups=[];bufferGroups=[];constructor(shaders,options){if(shaders)this.init(shaders,options)}init=(shaders,options={})=>{Object.assign(this,options);if(!this.device)throw new Error(`
    No GPUDevice! Please retrieve e.g. via: 
    
    const gpu = navigator.gpu;
    const adapter = await gpu.requestAdapter();
    if(!adapter) throw new Error('No GPU Adapter found!');
    device = await adapter.requestDevice();
    shaderhelper.init(shaders,{device});
`);if(!options.device)options.device=this.device;if(shaders.fragment&&!shaders.vertex)shaders=this.generateShaderBoilerplate(shaders,options);if(!options.skipCombinedBindings){if(shaders.compute&&shaders.vertex){let combined=WGSLTranspiler.combineBindings(shaders.compute.code,shaders.vertex.code);shaders.compute.code=combined.code1;shaders.compute.altBindings=Object.keys(combined.changes1).length>0?combined.changes1:void 0;shaders.vertex.code=combined.code2;shaders.vertex.altBindings=Object.keys(combined.changes2).length>0?combined.changes2:void 0}if(shaders.compute&&shaders.fragment){let combined=WGSLTranspiler.combineBindings(shaders.compute.code,shaders.fragment.code);shaders.compute.code=combined.code1;shaders.compute.altBindings=Object.keys(combined.changes1).length>0?combined.changes1:void 0;shaders.fragment.code=combined.code2;shaders.fragment.altBindings=Object.keys(combined.changes2).length>0?combined.changes2:void 0}if(shaders.vertex&&shaders.fragment){let combined=WGSLTranspiler.combineBindings(shaders.vertex.code,shaders.fragment.code);shaders.vertex.code=combined.code1;shaders.vertex.altBindings=Object.keys(combined.changes1).length>0?combined.changes1:void 0;shaders.fragment.code=combined.code2;shaders.fragment.altBindings=Object.keys(combined.changes2).length>0?combined.changes2:void 0}if(shaders.vertex?.params&&shaders.fragment){if(shaders.fragment.params)shaders.vertex.params.push(...shaders.fragment.params);shaders.fragment.params=shaders.vertex.params}}Object.assign(this.prototypes,shaders);if(shaders.compute){this.compute=new ShaderContext(Object.assign({},shaders.compute,options));this.compute.helper=this;Object.assign(this.compute,options)}if(shaders.fragment&&shaders.vertex){WGSLTranspiler.combineShaderParams(shaders.vertex,shaders.fragment)}if(shaders.fragment){this.fragment=new ShaderContext(Object.assign({},shaders.fragment,options));this.fragment.helper=this}if(shaders.vertex){this.vertex=new ShaderContext(Object.assign({},shaders.vertex,options));this.vertex.helper=this}if(this.compute){this.compute.bindGroupLayouts=this.bindGroupLayouts;this.compute.bindGroups=this.bindGroups;this.compute.bufferGroups=this.bufferGroups;const entries=this.compute.createBindGroupEntries(options?.renderPass?.textures);this.compute.bindGroupLayoutEntries=entries.length>0?entries:void 0;this.compute.setBindGroupLayout(entries,options.bindGroupNumber)}if(this.fragment){this.fragment.bufferGroups=this.bufferGroups;this.fragment.bindGroups=this.bindGroups;this.fragment.bindGroupLayouts=this.bindGroupLayouts;const entries=this.fragment.createBindGroupEntries(options?.renderPass?.textures,void 0,GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT);this.fragment.bindGroupLayoutEntries=entries.length>0?entries:void 0;this.fragment.setBindGroupLayout(entries,options.bindGroupNumber)}else if(this.vertex){this.vertex.bufferGroups=this.bufferGroups;this.vertex.bindGroups=this.bindGroups;this.vertex.bindGroupLayouts=this.bindGroupLayouts;const entries=this.vertex.createBindGroupEntries(options?.renderPass?.textures,void 0,GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT);this.vertex.bindGroupLayoutEntries=entries.length>0?entries:void 0;this.vertex.setBindGroupLayout(entries,options.bindGroupNumber)}if(this.compute){this.compute.shaderModule=this.device.createShaderModule({code:shaders.compute.code});if((this.compute.bindGroupLayoutEntries||this.compute.altBindings)&&this.bindGroupLayouts.length>0){this.compute.pipelineLayout=this.device.createPipelineLayout({label:"computeRenderPipelineDescriptor",bindGroupLayouts:this.bindGroupLayouts.filter(v=>{if(v)return true})})}const pipeline={layout:this.compute.pipelineLayout?this.compute.pipelineLayout:"auto",compute:{module:this.compute.shaderModule,entryPoint:"compute_main"}};if(options?.computePipelineSettings)Object.assign(pipeline,options?.computePipelineSettings);this.compute.computePipeline=this.device.createComputePipeline(pipeline)}if(this.vertex){this.vertex.shaderModule=this.device.createShaderModule({code:shaders.vertex.code})}if(this.fragment){this.fragment.shaderModule=this.device.createShaderModule({code:shaders.fragment.code})}if(this.vertex&&this.fragment){this.fragment.vertex=this.vertex;if((this.fragment.bindGroupLayoutEntries||this.fragment.altBindings)&&this.bindGroupLayouts.length>0){this.fragment.pipelineLayout=this.device.createPipelineLayout({label:"fragmentRenderPipelineDescriptor",bindGroupLayouts:this.bindGroupLayouts.filter(v=>{if(v)return true})})}this.fragment.updateGraphicsPipeline(options?.renderPass?.vbos,options?.contextSettings,options?.renderPipelineDescriptor,options?.renderPassDescriptor)}else if(this.vertex){if((this.vertex.bindGroupLayoutEntries||this.vertex.altBindings)&&this.bindGroupLayouts.length>0){this.vertex.pipelineLayout=this.device.createPipelineLayout({label:"vertexRenderPipelineDescriptor",bindGroupLayouts:this.bindGroupLayouts.filter(v=>{if(v)return true})})}this.vertex.updateGraphicsPipeline(options?.renderPass?.vbos,options?.contextSettings,options?.renderPipelineDescriptor,options?.renderPassDescriptor)}};addFunction=func=>{this.functions.push(func);for(const key of["compute","fragment","vertex"]){if(this.prototypes[key])Object.assign(this.prototypes[key],WGSLTranspiler.convertToWebGPU(this.prototypes[key].funcStr,key,this.prototypes[key].bindGroupNumber,this.prototypes[key].vbos,this.prototypes[key].workGroupSize?this.prototypes[key].workGroupSize:void 0,this.functions))}this.init(this.prototypes,{skipCombinedBindings:true})};generateShaderBoilerplate=(shaders,options)=>{for(const shaderType of["compute","vertex","fragment"]){const shaderContext=shaders[shaderType];if(!shaderContext)continue;if(shaderContext&&shaderType==="fragment"&&!shaders.vertex){let vboInputStrings=[];let vboStrings=[];if(options.vbos){const types=[];const keys=[];options.vbos.forEach(obj=>{keys.push(...Object.keys(obj));types.push(...Object.values(obj))});let loc=0;for(const key of keys){const type=types[loc];vboStrings.push(`@location(${loc}) ${key}: ${type}${loc===keys.length-1?"":","}`);vboInputStrings.push(`@location(${loc}) ${key}In: ${type}${loc===keys.length-1?"":","}`);loc++}}this.vertex={code:`
struct Vertex {
    @builtin(position) position: vec4<f32>, //pixel location
    //uploaded vertices from CPU, in interleaved format
    ${vboStrings.join("\n")}
};

@vertex
fn vtx_main(
    @builtin(vertex_index) vertexIndex : u32,   //current vertex
    @builtin(instance_index) instanceIndex: u32, //current instance
    ${vboInputStrings}
) -> Vertex {
    var pixel: Vertex;
    pixel.color = pixel.position[vertexId];
    pixel.vertex = pixel.position[vertexId];
    return pixel;
}`}}shaderContext.device=this.device}return shaders};cleanup=()=>{if(this.device)this.device.destroy();if(this.context)this.context?.unconfigure()};static flattenArray(arr){let result=[];for(let i=0;i<arr.length;i++){if(Array.isArray(arr[i])){result=result.concat(this.flattenArray(isTypedArray(arr[i])?Array.from(arr[i]):arr[i]))}else{result.push(arr[i])}}return result}static combineVertices(vertices,colors,uvs,normals){let length=0;if(colors)length=colors.length/4;if(vertices?.length/4>length)length=vertices.length/4;if(normals?.length/3>length)length=normals.length/3;if(uvs?.length/2>length)length=uvs.length/2;const vertexCount=length;const interleavedVertices=new Float32Array(vertexCount*13);for(let i=0;i<vertexCount;i++){const posOffset=i*4;const colOffset=i*4;const norOffset=i*3;const uvOffset=i*2;const interleavedOffset=i*13;interleavedVertices[interleavedOffset]=vertices?vertices[posOffset]||0:0;interleavedVertices[interleavedOffset+1]=vertices?vertices[posOffset+1]||0:0;interleavedVertices[interleavedOffset+2]=vertices?vertices[posOffset+2]||0:0;interleavedVertices[interleavedOffset+3]=vertices?vertices[posOffset+3]||0:0;interleavedVertices[interleavedOffset+4]=colors?colors[colOffset]||0:0;interleavedVertices[interleavedOffset+5]=colors?colors[colOffset+1]||0:0;interleavedVertices[interleavedOffset+6]=colors?colors[colOffset+2]||0:0;interleavedVertices[interleavedOffset+7]=colors?colors[colOffset+3]||0:0;interleavedVertices[interleavedOffset+8]=uvs?uvs[uvOffset]||0:0;interleavedVertices[interleavedOffset+9]=uvs?uvs[uvOffset+1]||0:0;interleavedVertices[interleavedOffset+10]=normals?normals[norOffset]||0:0;interleavedVertices[interleavedOffset+11]=normals?normals[norOffset+1]||0:0;interleavedVertices[interleavedOffset+12]=normals?normals[norOffset+2]||0:0}return interleavedVertices}static splitVertices(interleavedVertices){const vertexCount=interleavedVertices.length/13;const colors=new Float32Array(vertexCount*4);const vertices=new Float32Array(vertexCount*4);const normal=new Float32Array(vertexCount*3);const uvs=new Float32Array(vertexCount*2);for(let i=0;i<vertexCount;i++){const posOffset=i*4;const colOffset=i*4;const norOffset=i*3;const uvOffset=i*2;const offset=i*13;vertices[posOffset]=interleavedVertices[offset];vertices[posOffset+1]=interleavedVertices[offset+1];vertices[posOffset+2]=interleavedVertices[offset+2];vertices[posOffset+3]=interleavedVertices[offset+3];colors[colOffset]=interleavedVertices[offset+4];colors[colOffset+1]=interleavedVertices[offset+5];colors[colOffset+2]=interleavedVertices[offset+7];colors[colOffset+3]=interleavedVertices[offset+8];uvs[uvOffset]=interleavedVertices[offset+8];uvs[uvOffset+1]=interleavedVertices[offset+9];normal[norOffset]=interleavedVertices[offset+10];normal[norOffset+1]=interleavedVertices[offset+11];normal[norOffset+2]=interleavedVertices[offset+12]}return{vertices,colors,normal,uvs}}};var ShaderContext=class{canvas;context;device;helper;vertex;code;header;ast;params;funcStr;defaultUniforms;type;workGroupSize;returnedVars;functions;shaderModule;pipelineLayout;computePass;renderPass;computePipeline;graphicsPipeline;depthTexture;renderPassDescriptor;indexBuffer;indexFormat;contextSettings;altBindings;builtInUniforms;bufferGroup;bufferGroups=[];bindings;bindGroups=[];bindGroupLayouts=[];bindGroupNumber;bindGroupLayout;bindGroupLayoutEntries;vertexBufferOptions;constructor(props){Object.assign(this,props);const bIUCopy={};for(const key in WGSLTranspiler.builtInUniforms){bIUCopy[key]=Object.assign({},WGSLTranspiler.builtInUniforms[key])}this.builtInUniforms=bIUCopy}createBindGroupEntries=(textures,bindGroupNumber=this.bindGroupNumber,visibility=GPUShaderStage.COMPUTE|GPUShaderStage.FRAGMENT)=>{let bufferIncr=0;let uniformBufferIdx;let bufferGroup=this.bufferGroups[bindGroupNumber];if(!bufferGroup){bufferGroup=this.makeBufferGroup(bindGroupNumber)}if(textures)for(const key in textures){let isStorage=bufferGroup.params.find((node,i)=>{if(node.name===key&&node.isStorageTexture)return true});if(isStorage)textures[key].isStorage=true;this.updateTexture(textures[key],key,bindGroupNumber)}let texKeys;let texKeyRot=0;let baseMipLevel=0;if(bufferGroup.textures)texKeys=Object.keys(bufferGroup.textures);let assignedEntries={};const entries=bufferGroup.params?bufferGroup.params.map((node,i)=>{if(node.group!==bindGroupNumber)return void 0;assignedEntries[node.name]=true;let isReturned=bufferGroup.returnedVars===void 0||bufferGroup.returnedVars?.includes(node.name);if(node.isUniform){if(typeof uniformBufferIdx==="undefined"){uniformBufferIdx=i;bufferIncr++;const buffer={name:"uniform",binding:uniformBufferIdx,visibility,buffer:{type:"uniform"}};if(this.bindings?.[node.name])Object.assign(buffer,this.bindings[node.name]);return buffer}else return void 0}else if(node.isTexture||node.isStorageTexture){const buffer={name:node.name,binding:node.binding,visibility};if(node.isDepthTexture)buffer.texture={sampleType:"depth"};else if(bufferGroup.textures?.[node.name]){buffer.texture={sampleType:"float",viewDimension:node.name.includes("3d")?"3d":node.name.includes("1d")?"1d":node.name.includes("2darr")?"2d-array":"2d"};let viewSettings=void 0;if(bufferGroup.textures[node.name]){if(bufferGroup.textures[node.name].mipLevelCount){if(!viewSettings)viewSettings={};viewSettings.baseMipLevel=baseMipLevel;viewSettings.mipLevelCount=bufferGroup.textures[node.name].mipLevelCount;baseMipLevel++}}buffer.resource=bufferGroup.textures?.[node.name]?bufferGroup.textures[node.name].createView(viewSettings):{}}else if(node.isStorageTexture&&!node.isSharedStorageTexture){buffer.storageTexture={access:"write-only",format:bufferGroup.textures[node.name]?.format?bufferGroup.textures[node.name].format:"rgbaunorm",viewDimension:node.name.includes("3d")?"3d":node.name.includes("1d")?"1d":node.name.includes("2darr")?"2d-array":"2d"}}else{buffer.texture={sampleType:"unfilterable-float"}}if(this.bindings?.[node.name])Object.assign(buffer,this.bindings[node.name]);bufferIncr++;return buffer}else if(node.isSampler){if(!bufferGroup.samplers?.[node.name]){const sampler=this.device.createSampler(texKeys&&bufferGroup.textures[texKeys[texKeyRot]]?.samplerSettings?.[node.name]?bufferGroup.textures[texKeys[texKeyRot]]?.samplerSettings[node.name]:{magFilter:"linear",minFilter:"linear",mipmapFilter:"linear"});bufferGroup.samplers[node.name]=sampler}const buffer={name:node.name,binding:node.binding,visibility,sampler:{},resource:bufferGroup.samplers[node.name]||{}};texKeyRot++;if(texKeyRot>=texKeys?.length)texKeyRot=0;bufferIncr++;if(this.bindings?.[node.name])Object.assign(buffer,this.bindings[node.name]);return buffer}else{const buffer={name:node.name,binding:node.binding,visibility,buffer:{type:isReturned||node.isModified?"storage":"read-only-storage"}};bufferIncr++;if(this.bindings?.[node.name])Object.assign(buffer,this.bindings[node.name]);return buffer}}).filter((v,i)=>{if(v)return true}):[];if(this.bindings){for(const key in this.bindings){if(!assignedEntries[key])entries.push(this.bindings[key])}}if(bufferGroup.defaultUniforms){entries.push({name:"defaultUniforms",binding:bufferIncr,visibility,buffer:{type:"uniform"}})}this.bindGroupLayoutEntries=entries;return entries};setBindGroupLayout=(entries=[],bindGroupNumber=this.bindGroupNumber)=>{if(entries.length>0){this.bindGroupLayout=this.device.createBindGroupLayout({entries});this.bindGroupLayouts[bindGroupNumber]=this.bindGroupLayout;this.pipelineLayout=this.device.createPipelineLayout({bindGroupLayouts:this.bindGroupLayouts.filter(v=>{if(v)return true})})}return this.bindGroupLayout};updateVBO=(vertices,index=0,bufferOffset=0,dataOffset=0,bindGroupNumber=this.bindGroupNumber,indexBuffer,indexFormat)=>{let bufferGroup=this.bufferGroups[bindGroupNumber];if(!bufferGroup){bufferGroup=this.makeBufferGroup(bindGroupNumber)}if(vertices){if(vertices instanceof GPUBuffer){if(indexBuffer){if(!bufferGroup.indexCount)bufferGroup.indexCount=1;bufferGroup.indexBuffer=vertices}else{if(!bufferGroup.vertexBuffers)bufferGroup.vertexBuffers=[];bufferGroup.vertexBuffers[index]=vertices}}else{if(Array.isArray(vertices)){vertices=new Float32Array(ShaderHelper.flattenArray(vertices))}if(!isTypedArray(vertices))return;if(indexBuffer||bufferGroup.vertexBuffers?.[index]?.size!==vertices.byteLength){if(indexBuffer){if(!bufferGroup.indexCount)bufferGroup.indexCount=vertices.length}else{if(!bufferGroup.vertexBuffers)bufferGroup.vertexBuffers=[];if(!bufferGroup.vertexCount)bufferGroup.vertexCount=vertices.length?vertices.length/(this.vertexBufferOptions[index]?.__COUNT||4):1}if(indexBuffer){const vertexBuffer=this.device.createBuffer({label:"indexBuffer",size:vertices.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC|GPUBufferUsage.INDEX});bufferGroup.indexBuffer=vertexBuffer}else{const vertexBuffer=this.device.createBuffer({label:"vbo"+index,size:vertices.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});bufferGroup.vertexBuffers[index]=vertexBuffer}}if(indexBuffer){this.device.queue.writeBuffer(bufferGroup.indexBuffer,bufferOffset,vertices,dataOffset,vertices.length)}else{this.device.queue.writeBuffer(bufferGroup.vertexBuffers[index],bufferOffset,vertices,dataOffset,vertices.length)}}}};updateTexture=(data,name,bindGroupNumber=this.bindGroupNumber)=>{if(!data)return;if(!data.width&&data.source)data.width=data.source.width;if(!data.height&&data.source)data.height=data.source.height;let bufferGroup=this.bufferGroups[bindGroupNumber];if(!bufferGroup){bufferGroup=this.makeBufferGroup(bindGroupNumber)}const defaultDescriptor={label:data.label?data.label:`texture_g${bindGroupNumber}_${name}`,format:data.format?data.format:"rgba8unorm",size:[data.width,data.height,1],usage:data.usage?data.usage:data.source?GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|(data.isStorage?GPUTextureUsage.STORAGE_BINDING:GPUTextureUsage.RENDER_ATTACHMENT):data.isStorage?GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.STORAGE_BINDING:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST};const texture=this.device.createTexture(data.texture?Object.assign(defaultDescriptor,data.texture):defaultDescriptor);if(bufferGroup.textures[name])bufferGroup.textures[name].destroy();bufferGroup.textures[name]=texture;let texInfo={};if(data.source)texInfo.source=data.source;else texInfo.source=data;if(data.layout)Object.assign(texInfo,data.layout);if(data.buffer)this.device.queue.writeTexture(texInfo,data.buffer,{bytesPerRow:data.bytesPerRow?data.bytesPerRow:data.width*4},{width:data.width,height:data.height});else if(texInfo.source)this.device.queue.copyExternalImageToTexture(texInfo,{texture},[data.width,data.height]);return true};setUBOposition=(dataView,typeInfo,offset,input)=>{offset=Math.ceil(offset/typeInfo.alignment)*typeInfo.alignment;if(input!==void 0){if(typeInfo.type.startsWith("vec")){const vecSize=typeInfo.size/4;for(let j=0;j<vecSize;j++){if(typeInfo.type.includes("f"))dataView.setFloat32(offset+j*4,input[j],true);else dataView.setInt32(offset+j*4,input[j],true)}}else if(typeInfo.type.startsWith("mat")){const flatMatrix=typeof input[0]==="object"?ShaderHelper.flattenArray(input):input;for(let j=0;j<flatMatrix.length;j++){dataView.setFloat32(offset+j*4,flatMatrix[j],true)}}else{switch(typeInfo.type){case"f32":case"f":dataView.setFloat32(offset,input,true);break;case"i32":case"i":dataView.setInt32(offset,input,true);break;case"u32":case"u":dataView.setUint32(offset,input,true);break;case"f16":case"h":dataView.setUint16(offset,floatToHalf(input),true);case"i16":dataView.setInt16(offset,input,true);break;case"u16":dataView.setUint16(offset,input,true);break;case"i8":dataView.setInt8(offset,input);break;case"u8":dataView.setUint8(offset,input);break}}}offset+=typeInfo.size;return offset};updateArrayBuffers(buffers,updateBindGroup=false,bindGroupNumber=this.bindGroupNumber){const inputBuffers=this.bufferGroups[bindGroupNumber]?.inputBuffers;for(const key in buffers){if(buffers[key]instanceof GPUBuffer){inputBuffers[key]=buffers[key]}else{inputBuffers[key]=this.device.createBuffer({label:key,size:buffers[key]?buffers[key].byteLength?buffers[key].byteLength:buffers[key]?.length?buffers[key].length*4:8:8,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST|GPUBufferUsage.VERTEX,mappedAtCreation:true});new Float32Array(inputBuffers[key].getMappedRange()).set(buffers[key]);inputBuffers[key].unmap()}}if(updateBindGroup){this.updateBindGroup(bindGroupNumber)}}updateUBO=(inputs,newBuffer=false,updateBindGroup,bindGroupNumber=this.bindGroupNumber)=>{if(!inputs||Object.keys(inputs).length===0)return;if(newBuffer){this.allocateUBO(bindGroupNumber);if(updateBindGroup!==false)updateBindGroup=true}if(updateBindGroup){this.updateBindGroup(bindGroupNumber)}let bufferGroup=this.bufferGroups[bindGroupNumber];if(!bufferGroup){bufferGroup=this.makeBufferGroup(bindGroupNumber)}const inputTypes=this.bufferGroups[this.bindGroupNumber].inputTypes;if(bufferGroup.uniformBuffer){const dataView=this.getUBODataView(bindGroupNumber);let offset=0;let inpIdx=0;if(!bufferGroup.uniformBufferInputs){bufferGroup.uniformBufferInputs={}}bufferGroup.params.forEach((node,i)=>{if(node.isUniform){let input;if(Array.isArray(inputs))input=inputs[inpIdx];else input=inputs?.[node.name];if(typeof input==="undefined"&&typeof bufferGroup.uniformBufferInputs?.[inpIdx]!=="undefined")input=bufferGroup.uniformBufferInputs[inpIdx];const typeInfo=WGSLTypeSizes[inputTypes[inpIdx].type];bufferGroup.uniformBufferInputs[inpIdx]=input;offset=this.setUBOposition(dataView,typeInfo,offset,input)}if(node.isInput)inpIdx++});if(bufferGroup.uniformBuffer.mapState==="mapped")bufferGroup.uniformBuffer.unmap()}};updateDefaultUBO=(updateBindGroup=false,bindGroupNumber=this.bindGroupNumber)=>{let bufferGroup=this.bufferGroups[bindGroupNumber];if(!bufferGroup){bufferGroup=this.makeBufferGroup(bindGroupNumber)}if(bufferGroup.defaultUniforms){const dataView=bufferGroup.defaultUniformBuffer.mapState==="mapped"?new DataView(bufferGroup.defaultUniformBuffer.getMappedRange()):new DataView(new ArrayBuffer(bufferGroup.defaultUniformBuffer.size));let offset=0;bufferGroup.defaultUniforms.forEach((u,i)=>{let value=this.builtInUniforms[u]?.callback(this);const typeInfo=WGSLTypeSizes[this.builtInUniforms[bufferGroup.defaultUniforms[i]].type];offset=this.setUBOposition(dataView,typeInfo,offset,value)});if(bufferGroup.defaultUniformBuffer.mapState==="mapped")bufferGroup.defaultUniformBuffer.unmap();if(updateBindGroup){this.updateBindGroup(bindGroupNumber)}}};getUBODataView=(bindGroupNumber=this.bindGroupNumber)=>{let bufferGroup=this.bufferGroups[bindGroupNumber];if(!bufferGroup){bufferGroup=this.makeBufferGroup(bindGroupNumber)}const dataView=bufferGroup.uniformBuffer.mapState==="mapped"?new DataView(bufferGroup.uniformBuffer.getMappedRange()):new DataView(new ArrayBuffer(bufferGroup.uniformBuffer.size));return dataView};allocateUBO=(bindGroupNumber=this.bindGroupNumber)=>{let bufferGroup=this.bufferGroups[bindGroupNumber];if(!bufferGroup){bufferGroup=this.makeBufferGroup(bindGroupNumber)}if(!bufferGroup.totalUniformBufferSize){let totalUniformBufferSize=0;bufferGroup.params.forEach((node,j)=>{if(node.isInput&&node.isUniform){if(bufferGroup.inputTypes[j]){totalUniformBufferSize+=bufferGroup.inputTypes[j].size;if(totalUniformBufferSize%8!==0)totalUniformBufferSize+=WGSLTypeSizes[bufferGroup.inputTypes[j].type].alignment}}});if(totalUniformBufferSize<8)totalUniformBufferSize+=8-totalUniformBufferSize;else totalUniformBufferSize-=totalUniformBufferSize%16;bufferGroup.totalUniformBufferSize=totalUniformBufferSize}const uniformBuffer=this.device.createBuffer({label:"uniform",size:bufferGroup.totalUniformBufferSize?bufferGroup.totalUniformBufferSize:8,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_SRC,mappedAtCreation:true});bufferGroup.uniformBuffer=uniformBuffer;bufferGroup.inputBuffers.uniform=uniformBuffer;return true};createRenderPipelineDescriptor=(vertexBufferOptions=[{color:"vec4<f32>"}],swapChainFormat=navigator.gpu.getPreferredCanvasFormat(),renderPipelineDescriptor={})=>{const vertexBuffers=[];let loc=0;this.vertexBufferOptions=vertexBufferOptions;vertexBufferOptions.forEach((opt,i)=>{let arrayStride=0;const attributes=[];let ct=0;for(const key in opt){if(key==="stepMode"||key==="__COUNT")continue;const typeInfo=WGSLTypeSizes[opt[key]];const format=Object.keys(typeInfo.vertexFormats).find(f=>{if(f.startsWith("float32"))return true})||Object.values(typeInfo.vertexFormats)[0];ct+=typeInfo.ct;attributes.push({format,offset:arrayStride,shaderLocation:loc});arrayStride+=typeInfo.size;loc++}vertexBufferOptions[i].__COUNT=ct;const vtxState={arrayStride,attributes};if(opt.stepMode)vtxState.stepMode=opt.stepMode;vertexBuffers.push(vtxState)});let desc={label:"renderPipeline",layout:this.pipelineLayout?this.pipelineLayout:"auto",vertex:this.vertex?{module:this.vertex.shaderModule,entryPoint:"vtx_main",buffers:vertexBuffers}:{module:this.shaderModule,entryPoint:"vtx_main",targets:[{format:swapChainFormat}]},fragment:this.vertex?{module:this.shaderModule,entryPoint:"frag_main",targets:[{format:swapChainFormat}]}:void 0,depthStencil:{format:"depth24plus",depthWriteEnabled:true,depthCompare:"less"}};if(!this.vertex)delete renderPipelineDescriptor.fragment;renderPipelineDescriptor=Object.assign(desc,renderPipelineDescriptor);return renderPipelineDescriptor};createRenderPassDescriptor=()=>{const depthTexture=this.device.createTexture({size:[this.canvas.width,this.canvas.height],format:"depth24plus",usage:GPUTextureUsage.RENDER_ATTACHMENT});if(this.depthTexture)this.depthTexture.destroy();this.depthTexture=depthTexture;return{colorAttachments:[{view:void 0,clearValue:{r:0,g:0,b:0,a:0},loadOp:"clear",storeOp:"store"}],depthStencilAttachment:{view:void 0,depthLoadOp:"clear",depthClearValue:1,depthStoreOp:"store"}}};updateGraphicsPipeline=(vertexBufferOptions=[{color:"vec4<f32>"}],contextSettings,renderPipelineDescriptor,renderPassDescriptor)=>{const swapChainFormat=navigator.gpu.getPreferredCanvasFormat();this.context?.configure(contextSettings?contextSettings:{device:this.device,format:swapChainFormat,alphaMode:"premultiplied"});renderPipelineDescriptor=this.createRenderPipelineDescriptor(vertexBufferOptions,swapChainFormat,renderPipelineDescriptor);if(!renderPassDescriptor)renderPassDescriptor=this.createRenderPassDescriptor();this.renderPassDescriptor=renderPassDescriptor;this.graphicsPipeline=this.device.createRenderPipeline(renderPipelineDescriptor)};makeBufferGroup=(bindGroupNumber=this.bindGroupNumber)=>{const bufferGroup={};bufferGroup.params=this.params;bufferGroup.returnedVars=this.returnedVars;bufferGroup.defaultUniforms=this.defaultUniforms;bufferGroup.inputBuffers={};bufferGroup.outputBuffers=[];bufferGroup.textures={};bufferGroup.samplers={};bufferGroup.uniformBuffer=void 0;bufferGroup.bindGroupLayoutEntries=this.bindGroupLayoutEntries;this.bufferGroups[bindGroupNumber]=bufferGroup;if(!this.bufferGroup)this.bufferGroup=bufferGroup;return bufferGroup};firstRun=true;buffer=({vbos,textures,indexBuffer,indexFormat,skipOutputDef,bindGroupNumber,outputVBOs,outputTextures,newBindings}={},...inputs)=>{if(!bindGroupNumber)bindGroupNumber=this.bindGroupNumber;let bufferGroup=this.bufferGroups[bindGroupNumber];if(!bufferGroup){bufferGroup=this.makeBufferGroup(bindGroupNumber)}if(vbos){vbos.forEach((vertices,i)=>{this.updateVBO(vertices,i,void 0,void 0,bindGroupNumber)})}if(indexBuffer){this.updateVBO(indexBuffer,0,void 0,void 0,bindGroupNumber,true,indexFormat)}if(!bufferGroup.inputTypes&&bufferGroup.params)bufferGroup.inputTypes=bufferGroup.params.map(p=>{let type=p.type;if(type.startsWith("array")){type=type.substring(6,type.length-1)}return WGSLTypeSizes[type]});const inputBuffers=bufferGroup.inputBuffers;const outputBuffers=bufferGroup.outputBuffers;const params=bufferGroup.params;let newBindGroupBuffer=newBindings;if(inputs.length>0){newBindGroupBuffer=true}else if(!bufferGroup.bindGroup)newBindGroupBuffer=true;if(textures){const entries=this.createBindGroupEntries(textures,bindGroupNumber,this.vertex||!this.vertex&&this.graphicsPipeline?GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT:void 0);this.bindGroupLayoutEntries=entries;bufferGroup.bindGroupLayoutEntries=entries;this.setBindGroupLayout(entries,bindGroupNumber);newBindGroupBuffer=true}if(newBindGroupBuffer&&bindGroupNumber===this.bindGroupNumber){bufferGroup.bindGroupLayoutEntries=this.bindGroupLayoutEntries}let uBufferPushed=false;let inpBuf_i=0;let inpIdx=0;let hasUniformBuffer=0;let uBufferSet=false;let bindGroupAlts=[];let uniformValues=[];if(params)for(let i=0;i<params.length;i++){const node=params[i];if(typeof inputs[inpBuf_i]!=="undefined"&&this.altBindings?.[node.name]&&parseInt(this.altBindings?.[node.name].group)!==bindGroupNumber){if(!bindGroupAlts[this.altBindings?.[node.name].group]){bindGroupAlts[this.altBindings?.[node.name].group]=[]}bindGroupAlts[this.altBindings?.[node.name].group][this.altBindings?.[node.name].group]=inputs[i]}else{if(node.isUniform&&typeof inputs[inpBuf_i]!=="undefined"){uniformValues[inpIdx]=inputs[inpIdx];if(!bufferGroup.uniformBuffer||!uBufferSet){uBufferSet=this.allocateUBO(bindGroupNumber);bufferGroup.uniformBufferIndex=inpBuf_i}if(!hasUniformBuffer){hasUniformBuffer=1;inpBuf_i++}inpIdx++}else{if(typeof inputs[inpBuf_i]!=="undefined"||!inputBuffers[node.name]){if(!inputs?.[inpBuf_i]?.byteLength&&Array.isArray(inputs[inpBuf_i]?.[0]))inputs[inpBuf_i]=ShaderHelper.flattenArray(inputs[inpBuf_i]);if(inputBuffers[node.name]&&inputs[inpBuf_i].length===inputBuffers[node.name].size/4){let buf=new Float32Array(inputs[inpBuf_i]);this.device.queue.writeBuffer(inputBuffers[node.name],0,buf,buf.byteOffset,buf.length||8);inputBuffers[node.name].unmap()}else{if(inputs[inpBuf_i]instanceof GPUBuffer){inputBuffers[node.name]=inputs[inpBuf_i]}else{inputBuffers[node.name]=this.device.createBuffer({label:node.name,size:inputs[inpBuf_i]?inputs[inpBuf_i].byteLength?inputs[inpBuf_i].byteLength:inputs[inpBuf_i]?.length?inputs[inpBuf_i].length*4:8:8,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST|GPUBufferUsage.VERTEX,mappedAtCreation:true});new Float32Array(inputBuffers[node.name].getMappedRange()).set(inputs[inpBuf_i]||new Float32Array(1));inputBuffers[node.name].unmap()}}}inpBuf_i++;inpIdx++}if(!skipOutputDef&&node.isReturned&&(!node.isUniform||node.isUniform&&!uBufferPushed)){if(!node.isUniform){outputBuffers[inpBuf_i-1]=inputBuffers[node.name]}else if(!uBufferPushed){uBufferPushed=true;outputBuffers[inpBuf_i-1]=bufferGroup.uniformBuffer}}}};if(bufferGroup.vertexBuffers&&outputVBOs){outputBuffers.push(...bufferGroup.vertexBuffers)}if(bufferGroup.textures&&outputTextures){for(const key in bufferGroup.textures){outputBuffers.push(bufferGroup.textures[key])}}bindGroupAlts.forEach((inp,i)=>{if(inp&&i!==bindGroupNumber)this.buffer({bindGroupNumber:i},...inp)});if(bufferGroup.defaultUniforms){if(!bufferGroup.totalDefaultUniformBufferSize){let totalUniformBufferSize=0;bufferGroup.defaultUniforms.forEach(u=>{totalUniformBufferSize+=WGSLTypeSizes[this.builtInUniforms[u].type].size});if(totalUniformBufferSize<8)totalUniformBufferSize+=8-totalUniformBufferSize;else totalUniformBufferSize-=totalUniformBufferSize%16;bufferGroup.totalDefaultUniformBufferSize=totalUniformBufferSize}bufferGroup.defaultUniformBuffer=this.device.createBuffer({label:"defaultUniforms",size:bufferGroup.totalDefaultUniformBufferSize,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_SRC,mappedAtCreation:true});if(!bufferGroup.defaultUniformBinding){bufferGroup.defaultUniformBinding=Object.keys(inputBuffers).length}}if(uniformValues.length>0)this.updateUBO(uniformValues,false,false,bindGroupNumber);this.updateDefaultUBO(false,bindGroupNumber);if(this.bindGroupLayouts[bindGroupNumber]&&newBindGroupBuffer){this.updateBindGroup(bindGroupNumber)}return newBindGroupBuffer};updateBindGroup=(bindGroupNumber=this.bindGroupNumber)=>{let bufferGroup=this.bufferGroups[bindGroupNumber];if(!bufferGroup){bufferGroup=this.makeBufferGroup(bindGroupNumber)}const inputBuffers=bufferGroup.inputBuffers;if(this.bindGroupLayouts?.[bindGroupNumber]){let bindGroupEntries=[];if(bufferGroup.bindGroupLayoutEntries){bindGroupEntries.push(...bufferGroup.bindGroupLayoutEntries);let inpBufi=0;bufferGroup.bindGroupLayoutEntries.forEach((entry,i)=>{let type=entry.buffer?.type;const key=entry.name||i;if(type){if(type.includes("storage")&&inputBuffers[key]&&inputBuffers[key].label!=="uniform"){entry.resource={buffer:inputBuffers[key]};inpBufi++}else if(type.includes("uniform")&&bufferGroup.uniformBuffer){entry.resource={buffer:bufferGroup.uniformBuffer};inpBufi++}}});if(bufferGroup.defaultUniformBuffer)bindGroupEntries[bindGroupEntries.length-1].resource={buffer:bufferGroup.defaultUniformBuffer}}else if(inputBuffers){bindGroupEntries.push(...Object.values(inputBuffers).map((buffer,index)=>({binding:index,resource:{buffer}})));if(bufferGroup.defaultUniformBuffer)bindGroupEntries.push({binding:bufferGroup.defaultUniformBinding,resource:{buffer:bufferGroup.defaultUniformBuffer}})}const bindGroup=this.device.createBindGroup({label:`group_${bindGroupNumber}`,layout:this.bindGroupLayouts[bindGroupNumber],entries:bindGroupEntries});bufferGroup.bindGroup=bindGroup;this.bindGroups[bindGroupNumber]=bindGroup}};getOutputData=(commandEncoder,outputBuffers)=>{if(!outputBuffers)outputBuffers=this.bufferGroups[this.bindGroupNumber].outputBuffers;const stagingBuffers=outputBuffers.map(outputBuffer=>{return this.device.createBuffer({size:outputBuffer.size,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST})});outputBuffers.forEach((outputBuffer,index)=>{if(outputBuffer.width){commandEncoder.copyTextureToBuffer(outputBuffer,stagingBuffers[index],[outputBuffer.width,outputBuffer.height,outputBuffer.depthOrArrayLayers])}else commandEncoder.copyBufferToBuffer(outputBuffer,0,stagingBuffers[index],0,outputBuffer.size)});this.device.queue.submit([commandEncoder.finish()]);const promises=stagingBuffers.map((buffer,i)=>{return new Promise(resolve=>{buffer.mapAsync(GPUMapMode.READ).then(()=>{const mappedRange=buffer.getMappedRange();const rawResults=outputBuffers[i].format?.includes("8")?new Uint8Array(mappedRange):new Float32Array(mappedRange);const copiedResults=outputBuffers[i].format?.includes("8")?new Uint8Array(rawResults.length):new Float32Array(rawResults.length);copiedResults.set(rawResults);buffer.unmap();resolve(copiedResults)})})});return promises.length===1?promises[0]:Promise.all(promises)};run=({vertexCount,instanceCount,firstVertex,firstInstance,vbos,outputVBOs,textures,outputTextures,bufferOnly,skipOutputDef,bindGroupNumber,viewport,scissorRect,blendConstant,indexBuffer,indexFormat,firstIndex,useRenderBundle,workgroupsX,workgroupsY,workgroupsZ,newBindings}={},...inputs)=>{if(!bindGroupNumber)bindGroupNumber=this.bindGroupNumber;const newInputBuffer=(inputs.length>0||vbos||textures||indexBuffer)&&this.buffer({vbos,textures,indexBuffer,indexFormat,skipOutputDef,bindGroupNumber,outputVBOs,outputTextures,newBindings},...inputs);if(!bufferOnly){const bufferGroup=this.bufferGroups[bindGroupNumber];if(!bufferGroup)this.makeBufferGroup(bindGroupNumber);const commandEncoder=this.device.createCommandEncoder();if(this.computePipeline){const computePass=commandEncoder.beginComputePass();computePass.setPipeline(this.computePipeline);const withBindGroup=(group,i)=>{if(i===this.bindGroupNumber||this.altBindings)computePass.setBindGroup(i,group)};this.bindGroups.forEach(withBindGroup);const firstinp=Object.values(bufferGroup.inputBuffers)[0];let wX=workgroupsX?workgroupsX:firstinp?firstinp?.size/4/this.workGroupSize:1;computePass.dispatchWorkgroups(wX,workgroupsY,workgroupsZ);computePass.end()}if(this.graphicsPipeline){let renderPass;if(useRenderBundle&&(newInputBuffer||!bufferGroup.renderBundle)){if(!this.renderPassDescriptor.colorAttachments[0].view){const curTex=this.context.getCurrentTexture();const view=curTex.createView();this.renderPassDescriptor.colorAttachments[0].view=view}if(!this.renderPassDescriptor.depthStencilAttachment.view){const view=this.depthTexture.createView();this.renderPassDescriptor.depthStencilAttachment.view=view}renderPass=this.device.createRenderBundleEncoder({colorFormats:[navigator.gpu.getPreferredCanvasFormat()]});bufferGroup.firstPass=true}else{const curTex=this.context.getCurrentTexture();const view=curTex.createView();this.renderPassDescriptor.colorAttachments[0].view=view;const depthView=this.depthTexture.createView();this.renderPassDescriptor.depthStencilAttachment.view=depthView;renderPass=commandEncoder.beginRenderPass(this.renderPassDescriptor)}if(vertexCount)bufferGroup.vertexCount=vertexCount;else if(!bufferGroup.vertexCount)bufferGroup.vertexCount=1;if(!useRenderBundle||!bufferGroup.renderBundle){renderPass.setPipeline(this.graphicsPipeline);const withBindGroup=(group,i)=>{if(i===this.bindGroupNumber||this.altBindings)renderPass.setBindGroup(i,group)};this.bindGroups.forEach(withBindGroup);if(!bufferGroup.vertexBuffers?.length)this.updateVBO(new Float32Array(bufferGroup.vertexCount*4),0);if(bufferGroup.vertexBuffers)bufferGroup.vertexBuffers.forEach((vbo,i)=>{renderPass.setVertexBuffer(i,vbo)});if(!useRenderBundle){if(viewport){renderPass.setViewport(viewport.x,viewport.y,viewport.width,viewport.height,viewport.minDepth,viewport.maxDepth)}if(scissorRect){renderPass.setScissorRect(scissorRect.x,scissorRect.y,scissorRect.width,scissorRect.height)}if(blendConstant){renderPass.setBlendConstant(blendConstant)}}if(bufferGroup.indexBuffer){if(!bufferGroup.indexFormat)bufferGroup.indexFormat=indexFormat?indexFormat:"uint32";renderPass.setIndexBuffer(bufferGroup.indexBuffer,bufferGroup.indexFormat);renderPass.drawIndexed(bufferGroup.indexCount,instanceCount,firstIndex,0,firstInstance)}else{renderPass.draw(bufferGroup.vertexCount,instanceCount,firstVertex,firstInstance)}if(useRenderBundle&&bufferGroup.firstPass){bufferGroup.renderBundle=renderPass.finish();bufferGroup.firstPass=false}}else{renderPass.executeBundles([bufferGroup.renderBundle])}renderPass.end()}if(!skipOutputDef&&bufferGroup.outputBuffers?.length>0){return this.getOutputData(commandEncoder,bufferGroup.outputBuffers)}else{this.device.queue.submit([commandEncoder.finish()]);return new Promise(r=>r(true))}}}};function isTypedArray(x){return ArrayBuffer.isView(x)&&Object.prototype.toString.call(x)!=="[object DataView]"}function floatToHalf(float32){const float32View=new Float32Array(1);const int32View=new Int32Array(float32View.buffer);float32View[0]=float32;const f=int32View[0];const sign=(f>>>31)*32768;const exponent=(f>>>23&255)-127;const mantissa=f&8388607;if(exponent===128){return sign|31744|(mantissa?1:0)*(mantissa>>13)}if(exponent<-14){return sign}if(exponent>15){return sign|31744}const normalizedExponent=exponent+15;const normalizedMantissa=mantissa>>13;return sign|normalizedExponent<<10|normalizedMantissa}var WebGPUjs=class _WebGPUjs{static device;static createPipeline=async(shaders,options={})=>{let device=options.device;if(!device){device=_WebGPUjs.device;if(!device){const gpu=navigator.gpu;const adapter=await gpu.requestAdapter();if(!adapter)throw new Error("No GPU Adapter found!");device=await adapter.requestDevice();_WebGPUjs.device=device}options.device=device}if(options.canvas){if(!options.context)options.context=options.canvas.getContext("webgpu")}if(typeof shaders==="function"){const shader=WGSLTranspiler.convertToWebGPU(shaders,options.canvas?"fragment":"compute",options.bindGroupNumber,options.workGroupSize,options.renderPass?.vbos,options.functions,options.variableTypes,options.lastBinding);if(options.getPrevShaderBindGroups){let combined=WGSLTranspiler.combineBindings(shader.code,options.getPrevShaderBindGroups);shader.code=combined.code1;shader.altBindings=combined.changes1}let shaderPipeline;if(shader.type==="compute"){shaderPipeline=new ShaderHelper({compute:shader},options)}else{shaderPipeline=new ShaderHelper({fragment:shader},options)}return shaderPipeline}else{const block=shaders;if(block.code){if(typeof block.code==="function"||block.transpileString){block.code=WGSLTranspiler.convertToWebGPU(block.code,options.canvas?"fragment":"compute",options.bindGroupNumber,options.workGroupSize,options.renderPass?.vbos,options.functions,options.variableTypes,options.lastBinding)}if(options.getPrevShaderBindGroups){let combined=WGSLTranspiler.combineBindings(block.code,options.getPrevShaderBindGroups);block.code=combined.code1;block.altBindings=combined.changes1}const shaderPipeline=this.init(block,options);return shaderPipeline}else{if(block.compute){if(typeof block.compute==="function"||block.transpileString){block.compute=WGSLTranspiler.convertToWebGPU(block.compute,"compute",options.bindGroupNumber,options.workGroupSize,options.renderPass?.vbos,options.functions,options.variableTypes,options.lastBinding)}}if(block.vertex){if(typeof block.vertex==="function"||block.transpileString){block.vertex=WGSLTranspiler.convertToWebGPU(block.vertex,"vertex",block.compute?block.compute.bindGroupNumber+1:options.bindGroupNumber,options.workGroupSize,options.renderPass?.vbos,options.functions,options.variableTypes,options.lastBinding);options.lastBinding=block.vertex.lastBinding}}if(block.fragment){if(typeof block.fragment==="function"||block.transpileString){block.fragment=WGSLTranspiler.convertToWebGPU(block.fragment,"fragment",block.compute?block.compute.bindGroupNumber+1:options.bindGroupNumber,options.workGroupSize,options.renderPass?.vbos,options.functions,options.variableTypes,options.lastBinding)}}if(options.getPrevShaderBindGroups){for(const key in block){let combined=WGSLTranspiler.combineBindings(block[key].code,options.getPrevShaderBindGroups);block[key].code=combined.code1;block[key].altBindings=combined.changes1}}const shaderPipeline=new ShaderHelper(block,options);return shaderPipeline}}};static init=(shaders,options)=>{return new ShaderHelper(shaders,options)};static combineShaders=(shaders,options={},previousPipeline)=>{let bindGroupNumber=previousPipeline.bindGroupLayouts.length;options.device=previousPipeline.device;if(options.bindGroupLayouts)options.bindGroupLayouts;previousPipeline.bindGroupLayouts.push(...options.bindGroupLayouts);options.bindGroupNumber=bindGroupNumber;options.bindGroupLayouts=previousPipeline.bindGroupLayouts;options.bindGroups=previousPipeline.bindGroups;options.bufferGroups=previousPipeline.bufferGroups;if(previousPipeline.fragment){options.getPrevShaderBindGroups=previousPipeline.fragment.code}else if(previousPipeline.compute){options.getPrevShaderBindGroups=previousPipeline.compute.code}return _WebGPUjs.createPipeline(shaders,options)};static cleanup=shaderPipeline=>{if(shaderPipeline.device)shaderPipeline.device.destroy();if(shaderPipeline.context)shaderPipeline.context.unconfigure()}};var webgpujs_default=WebGPUjs;["WebGPUjs"].forEach(key=>{if(webgpujs_exports[key]){globalThis[key]=webgpujs_exports[key]}});})();
